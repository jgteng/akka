<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Interaction Patterns &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/interaction-patterns.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-6.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com/lightbend-platform" target="_blank">
<svg class="lightbend-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 372 80">
<title>Lightbend</title>
<g id="lightbend-reverse">
<path d="M1,59V76a3,3,0,0,0,3,3H88a3,3,0,0,0,3-3V59a167.38,167.38,0,0,1-45,6A167.38,167.38,0,0,1,1,59Z" fill="#fff" />
<path d="M88,1H4A3,3,0,0,0,1,4V53c14.57,4.2,29.65,7,45,7s30.43-2.8,45-7V4A3,3,0,0,0,88,1Z" fill="#fff" />
<g id="original_weight" data-name="original weight">
<path d="M107.2,20.08a2.14,2.14,0,1,1,4.27,0v32h13.6A2,2,0,0,1,127,54a1.94,1.94,0,0,1-1.94,2H109.31a2.15,2.15,0,0,1-2.11-2.16Z" fill="#fff" />
<path d="M135,19.32a2.47,2.47,0,0,1,4.91,0V20A2.47,2.47,0,0,1,135,20Zm.38,10.59a2.08,2.08,0,1,1,4.16,0V54.15a2,2,0,0,1-2.06,2.11,2.08,2.08,0,0,1-2.1-2.11Z" fill="#fff" />
<path d="M150.8,61.44a1.91,1.91,0,0,1-1.08-1.73,2,2,0,0,1,1.89-1.83,1.69,1.69,0,0,1,.92.27,17.63,17.63,0,0,0,9.88,3c6.15,0,10.15-3.4,10.15-9.93v-3.3c-2.43,3.24-5.83,5.89-11,5.89a12.9,12.9,0,0,1-13.12-13.07v-.11a13.21,13.21,0,0,1,24-7.56V29.91a2.07,2.07,0,0,1,2.06-2.11,2.11,2.11,0,0,1,2.1,2.11V51.13c0,4.32-1.29,7.61-3.56,9.88-2.49,2.48-6.21,3.73-10.64,3.73A21.87,21.87,0,0,1,150.8,61.44Zm21.87-20.73V40.6c0-5.72-5-9.45-10.26-9.45s-9.67,3.67-9.67,9.4v.1a9.45,9.45,0,0,0,9.67,9.51C167.7,50.16,172.67,46.32,172.67,40.71Z" fill="#fff" />
<path d="M186.22,18.41a2.08,2.08,0,1,1,4.16,0V32.93a10.57,10.57,0,0,1,9.56-5.45c6.75,0,10.69,4.53,10.69,11.18V54.15a2.08,2.08,0,1,1-4.16,0V39.68c0-5.18-2.81-8.42-7.72-8.42s-8.37,3.51-8.37,8.75V54.15a2,2,0,0,1-2,2.11,2.08,2.08,0,0,1-2.11-2.11Z" fill="#fff" />
<path d="M220.46,48.59V31.74h-2.27a1.89,1.89,0,0,1-1.84-1.83,1.86,1.86,0,0,1,1.84-1.84h2.27V21.48a2.06,2.06,0,0,1,2-2.1,2.14,2.14,0,0,1,2.1,2.1v6.59h7.24a1.91,1.91,0,0,1,1.89,1.84,1.86,1.86,0,0,1-1.89,1.83h-7.24V48.05c0,3.4,1.89,4.64,4.7,4.64a12,12,0,0,0,2.54-.37,1.8,1.8,0,0,1,1.78,1.78,1.73,1.73,0,0,1-1.19,1.62,10.57,10.57,0,0,1-4.1.75C223.86,56.47,220.46,54.26,220.46,48.59Z" fill="#fff" />
<path d="M242.65,18.41a2.08,2.08,0,1,1,4.16,0V33.69c2.27-3.35,5.56-6.21,10.69-6.21,6.7,0,13.34,5.29,13.34,14.47v.11c0,9.12-6.59,14.52-13.34,14.52a12.6,12.6,0,0,1-10.69-5.94v3.51a2.07,2.07,0,0,1-2.05,2.11,2.11,2.11,0,0,1-2.11-2.11Zm23.92,23.7V42c0-6.58-4.53-10.8-9.83-10.8A10.41,10.41,0,0,0,246.65,42v.11c0,6.48,4.91,10.8,10.09,10.8C262.14,52.86,266.57,48.86,266.57,42.11Z" fill="#fff" />
<path d="M290.17,56.64c-7.67,0-13.93-5.89-13.93-14.53V42c0-8,5.67-14.52,13.39-14.52,8.26,0,13,6.75,13,14.15a1.94,1.94,0,0,1-1.95,1.94H280.45c.59,6,4.86,9.45,9.83,9.45a11.4,11.4,0,0,0,8-3.24,1.83,1.83,0,0,1,1.19-.49,1.81,1.81,0,0,1,1.84,1.78,1.78,1.78,0,0,1-.65,1.35A14.2,14.2,0,0,1,290.17,56.64Zm8.26-16.15c-.43-5.07-3.35-9.5-8.91-9.5-4.86,0-8.53,4.05-9.07,9.5Z" fill="#fff" />
<path d="M309.5,29.91a2.08,2.08,0,1,1,4.16,0v3a10.57,10.57,0,0,1,9.56-5.45c6.75,0,10.69,4.53,10.69,11.18V54.15a2.08,2.08,0,1,1-4.16,0V39.68c0-5.18-2.81-8.42-7.72-8.42s-8.37,3.51-8.37,8.75V54.15a2,2,0,0,1-2.05,2.11,2.08,2.08,0,0,1-2.11-2.11Z" fill="#fff" />
<path d="M368.68,54.15a2.08,2.08,0,1,1-4.15,0V50.37c-2.27,3.35-5.57,6.21-10.7,6.21-6.69,0-13.33-5.29-13.33-14.47V42c0-9.12,6.64-14.52,13.33-14.52a12.61,12.61,0,0,1,10.7,5.94v-15a2,2,0,0,1,2.05-2.11,2.07,2.07,0,0,1,2.1,2.11ZM344.76,42v.11c0,6.58,4.59,10.8,9.83,10.8a10.43,10.43,0,0,0,10.1-10.8V42a10.38,10.38,0,0,0-10.1-10.75C349.19,31.2,344.76,35.2,344.76,42Z" fill="#fff" />
</g>
</g>
</svg>
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="See how Akka fits into Lightbend Platform [Button]" href="https://www.lightbend.com/akka-part-of-lightbend-platform" target="_blank">
<span>See how Akka fits into</span>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 274 80">
<title>Lightbend Platform</title>
<g id="lightbend-platform-reverse">
<g id="icon">
<path d="M1,59V76a3,3,0,0,0,3,3H88a3,3,0,0,0,3-3V59a167.38,167.38,0,0,1-45,6A167.38,167.38,0,0,1,1,59Z" fill="#fff" />
<path d="M88,1H4A3,3,0,0,0,1,4V53c14.57,4.2,29.65,7,45,7s30.43-2.8,45-7V4A3,3,0,0,0,88,1Z" fill="#fff" />
</g>
<g id="lightbend">
<path d="M104,14.73a1,1,0,1,1,2,0V29.4h6.24a.91.91,0,0,1,.89.92.88.88,0,0,1-.89.89H105a1,1,0,0,1-1-1Z" fill="#fff" />
<path d="M116.77,14.39a1.14,1.14,0,0,1,2.26,0v.32a1.14,1.14,0,0,1-2.26,0Zm.18,4.85a1,1,0,1,1,1.9,0V30.37a.93.93,0,0,1-.94,1,1,1,0,0,1-1-1Z" fill="#fff" />
<path d="M124,33.72a.89.89,0,0,1-.5-.8.91.91,0,0,1,.87-.84.8.8,0,0,1,.42.12,8.05,8.05,0,0,0,4.54,1.39C132.16,33.59,134,32,134,29V27.52a6,6,0,0,1-5,2.7,5.92,5.92,0,0,1-6-6v-.05a6.07,6.07,0,0,1,11-3.47V19.24a.94.94,0,0,1,.94-1,1,1,0,0,1,1,1V29a6.18,6.18,0,0,1-1.64,4.54,6.73,6.73,0,0,1-4.88,1.71A10,10,0,0,1,124,33.72Zm10-9.52v-.05a4.49,4.49,0,0,0-4.7-4.34,4.24,4.24,0,0,0-4.44,4.32v.05a4.34,4.34,0,0,0,4.44,4.36A4.52,4.52,0,0,0,134,24.2Z" fill="#fff" />
<path d="M140.26,14a1,1,0,1,1,1.91,0v6.66a4.84,4.84,0,0,1,4.39-2.5c3.1,0,4.9,2.08,4.9,5.13v7.11a1,1,0,1,1-1.9,0V23.73c0-2.38-1.29-3.87-3.55-3.87a3.77,3.77,0,0,0-3.84,4v6.49a.93.93,0,0,1-.94,1,1,1,0,0,1-1-1Z" fill="#fff" />
<path d="M156,27.82V20.09h-1a.87.87,0,0,1-.84-.85.85.85,0,0,1,.84-.84h1v-3a1,1,0,0,1,.94-1,1,1,0,0,1,1,1v3h3.32a.87.87,0,0,1,.87.84.85.85,0,0,1-.87.85h-3.32v7.48A1.9,1.9,0,0,0,160,29.7a5.31,5.31,0,0,0,1.16-.17.82.82,0,0,1,.82.82.79.79,0,0,1-.54.74,4.9,4.9,0,0,1-1.89.35A3.26,3.26,0,0,1,156,27.82Z" fill="#fff" />
<path d="M166.16,14a1,1,0,1,1,1.91,0v7A5.75,5.75,0,0,1,173,18.13c3.07,0,6.12,2.43,6.12,6.64v.05c0,4.19-3,6.67-6.12,6.67a5.78,5.78,0,0,1-4.91-2.73v1.61a1,1,0,0,1-.94,1,1,1,0,0,1-1-1Zm11,10.88V24.8c0-3-2.08-5-4.51-5A4.78,4.78,0,0,0,168,24.77v.05a4.78,4.78,0,0,0,4.64,5C175.11,29.78,177.14,27.94,177.14,24.85Z" fill="#fff" />
<path d="M188,31.51a6.37,6.37,0,0,1-6.4-6.66V24.8c0-3.7,2.61-6.67,6.15-6.67,3.79,0,5.95,3.1,5.95,6.49a.89.89,0,0,1-.89.89h-9.27A4.47,4.47,0,0,0,188,29.85a5.23,5.23,0,0,0,3.69-1.49.85.85,0,0,1,.54-.22.81.81,0,0,1,.55,1.44A6.52,6.52,0,0,1,188,31.51Zm3.79-7.41c-.2-2.33-1.54-4.36-4.09-4.36-2.23,0-3.91,1.86-4.16,4.36Z" fill="#fff" />
<path d="M196.84,19.24a1,1,0,1,1,1.91,0v1.39a4.84,4.84,0,0,1,4.38-2.5c3.1,0,4.91,2.08,4.91,5.13v7.11a1,1,0,1,1-1.91,0V23.73c0-2.38-1.29-3.87-3.54-3.87a3.77,3.77,0,0,0-3.84,4v6.49a.93.93,0,0,1-.94,1,1,1,0,0,1-1-1Z" fill="#fff" />
<path d="M224,30.37a1,1,0,1,1-1.91,0V28.64a5.77,5.77,0,0,1-4.9,2.85,6.25,6.25,0,0,1-6.13-6.64V24.8a6.29,6.29,0,0,1,6.13-6.67,5.78,5.78,0,0,1,4.9,2.73V14a.93.93,0,0,1,.94-1,1,1,0,0,1,1,1Zm-11-5.6v.05a4.64,4.64,0,0,0,4.51,5,4.79,4.79,0,0,0,4.64-5v-.05a4.76,4.76,0,0,0-4.64-4.93C215.05,19.84,213,21.67,213,24.77Z" fill="#fff" />
</g>
<path d="M103.36,41H114.8c6.68,0,10.72,4,10.72,9.68v.08c0,6.48-5,9.84-11.32,9.84h-4.68V69h-6.16Zm11,14.12c3.08,0,4.88-1.84,4.88-4.24V50.8c0-2.76-1.92-4.24-5-4.24h-4.76v8.56Z" fill="#fff" />
<path d="M128.89,39.8H135V69h-6.08Z" fill="#fff" />
<path d="M138.75,62.84v-.08c0-4.68,3.56-6.84,8.64-6.84a15.23,15.23,0,0,1,5.24.88v-.36c0-2.52-1.56-3.92-4.6-3.92a15.77,15.77,0,0,0-5.92,1.16L140.59,49a18.92,18.92,0,0,1,8.32-1.72c3.32,0,5.72.88,7.24,2.4s2.32,4,2.32,6.84V69h-5.88V66.68a8.24,8.24,0,0,1-6.48,2.72C142.07,69.4,138.75,67.08,138.75,62.84Zm14-1.4V60.36a9.43,9.43,0,0,0-3.88-.8c-2.6,0-4.2,1-4.2,3v.08c0,1.64,1.36,2.6,3.32,2.6C150.79,65.2,152.71,63.64,152.71,61.44Z" fill="#fff" />
<path d="M164,62.92V52.76h-2.56v-5.2H164V42.08h6.08v5.48h5v5.2h-5v9.16c0,1.4.6,2.08,2,2.08a6.18,6.18,0,0,0,3-.76v4.88a9,9,0,0,1-4.8,1.24C166.51,69.36,164,67.88,164,62.92Z" fill="#fff" />
<path d="M180.43,52.76h-2.52v-5h2.52V46.4a7,7,0,0,1,1.72-5.19,6.63,6.63,0,0,1,4.92-1.68,13.5,13.5,0,0,1,4.32.59v5a7.7,7.7,0,0,0-2.76-.52c-1.4,0-2.2.72-2.2,2.32v.84h4.92v5h-4.84V69h-6.08Z" fill="#fff" />
<path d="M192.84,58.4v-.08c0-6.16,5-11.16,11.64-11.16S216,52.08,216,58.24v.08c0,6.16-5,11.16-11.64,11.16S192.84,64.56,192.84,58.4Zm17.2,0v-.08a5.7,5.7,0,0,0-5.64-5.92c-3.48,0-5.56,2.68-5.56,5.84v.08a5.7,5.7,0,0,0,5.64,5.92C208,64.24,210,61.56,210,58.4Z" fill="#fff" />
<path d="M219.89,47.56H226v4.32c1.24-3,3.24-4.88,6.84-4.72v6.36h-.32c-4,0-6.52,2.44-6.52,7.56V69h-6.08Z" fill="#fff" />
<path d="M235.8,47.56h6.08v3a7.66,7.66,0,0,1,6.32-3.44,6.42,6.42,0,0,1,6,3.4,8.83,8.83,0,0,1,7-3.4c4.52,0,7.24,2.72,7.24,7.88V69h-6.08V57c0-2.88-1.28-4.36-3.56-4.36S255.2,54.16,255.2,57V69h-6.08V57c0-2.88-1.28-4.36-3.56-4.36s-3.68,1.48-3.68,4.36V69H235.8Z" fill="#fff" />
</g>
</svg>
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 752 192">
<title>Lagom Framework</title>
<g>
<g id="Lagom">
<path d="M291.58,31.79h19.83v87.92c0,8.1,2.65,11.57,9.92,11.57a21.37,21.37,0,0,0,5.95-.66V148.3a35.73,35.73,0,0,1-9.42,1c-17.52,0-26.28-8.92-26.28-26.94Z" fill="#652b7c" />
<path d="M398.34,75.75V63.69h19.83v58.17c0,7.1,1.65,9.75,6.11,9.75,1.16,0,2.64-.17,4.13-.33v16a28.83,28.83,0,0,1-9.75,1.32c-4.79,0-8.59-.83-11.57-2.65a15.32,15.32,0,0,1-6.77-10.08C394.53,144.66,385,149,371.73,149A39.59,39.59,0,0,1,342,136.4c-7.93-8.43-11.89-18.67-11.89-31.07s4-22.64,11.89-30.9a39.59,39.59,0,0,1,29.75-12.56C385.12,61.87,395.2,67.82,398.34,75.75Zm-5.95,47.76a24.32,24.32,0,0,0,7.43-18.18,24.34,24.34,0,0,0-7.43-18.18,24.71,24.71,0,0,0-18-7.27,23.94,23.94,0,0,0-17.68,7.27c-4.63,4.8-6.94,10.91-6.94,18.18s2.31,13.39,6.94,18.18a23.94,23.94,0,0,0,17.68,7.27A24.71,24.71,0,0,0,392.39,123.51Z" fill="#652b7c" />
<path d="M495.67,63.69H515.5v69.4c0,20-2.81,32.23-14.05,41-7.93,6.11-17.68,9.25-29.41,9.25-15.54,0-28.92-4-40.32-12.06l9.58-14.71a50.5,50.5,0,0,0,28.59,9.09q11.66,0,18.34-5c5.29-3.8,7.94-10.91,7.94-21.15v-4.13c-4,7.1-13.89,12.23-27.11,12.23a40.51,40.51,0,0,1-29.74-12.23c-7.93-8.1-11.9-18.35-11.9-30.41s4-22.31,12.06-30.57a39.23,39.23,0,0,1,29.58-12.56c13.72,0,23.8,5.78,26.61,13.88ZM489.72,123a24.16,24.16,0,0,0,7.44-18,23.84,23.84,0,0,0-7.44-17.85,24.69,24.69,0,0,0-18-7.27A23.92,23.92,0,0,0,454,87.15,24.7,24.7,0,0,0,447.09,105,25,25,0,0,0,454,123a23.75,23.75,0,0,0,17.68,7.11C478.81,130.12,484.93,127.81,489.72,123Z" fill="#652b7c" />
<path d="M522.44,105.33a42.06,42.06,0,0,1,13.22-31.4c8.76-8.43,19.5-12.72,32.22-12.72s23.47,4.29,32.23,12.72a42.06,42.06,0,0,1,13.22,31.4,42,42,0,0,1-13.22,31.4c-8.76,8.43-19.5,12.72-32.23,12.72s-23.46-4.29-32.22-12.72A42,42,0,0,1,522.44,105.33ZM586.23,124a25.68,25.68,0,0,0,7.43-18.68,25,25,0,0,0-7.43-18.51,26.13,26.13,0,0,0-36.85,0,25.58,25.58,0,0,0-7.27,18.51A26.25,26.25,0,0,0,549.38,124a26.56,26.56,0,0,0,36.85,0Z" fill="#652b7c" />
<path d="M620.6,147V63.69h19.67v11.9C643.74,67.49,652,62,662.58,62,674,62,681.91,66.83,686,76.58,690.84,66.83,699.76,62,712.81,62c18,0,28.43,12.72,28.43,33.38v26.27c0,6.45,1.15,8.76,5.62,8.76a15,15,0,0,0,2.81-.33v16.69a28.48,28.48,0,0,1-8.6,1c-13.05,0-19.5-7.27-19.5-21.81V98.23c0-11.41-5.28-18.51-14.54-18.51s-16,8.09-16,19.33V147H671.34V98.23c0-11.41-5.46-18.51-14.88-18.51-9.25,0-16.19,8.09-16.19,19.33V147Z" fill="#652b7c" />
</g>
<g id="Icon">
<path d="M261,84l-70,34,70,34S260.78,84.27,261,84Z" fill="#652b7c" />
<polygon points="121 152 191 118 121 84 121 152" fill="#652b7c" />
<path d="M191,118l70,34c-.27,0-41.76,25-60.63,36.24a17.63,17.63,0,0,1-18,0C163.47,177,121,152,121,152Z" fill="#421540" />
<path d="M200.23,47.65C219.09,58.88,261,84,261,84l-70,34L121,84c.27,0,42.31-25.12,61.18-36.36A17.67,17.67,0,0,1,200.23,47.65Z" fill="#bf97c6" />
<path d="M145,20.58l-35,17,35,17S144.89,20.72,145,20.58Z" fill="#652b7c" />
<polygon points="75 54.58 110 37.58 75 20.58 75 54.58" fill="#652b7c" />
<path d="M110,37.58l35,17c-.14,0-20.88,12.5-30.31,18.12a8.81,8.81,0,0,1-9,0C96.23,67.08,75,54.58,75,54.58Z" fill="#421540" />
<path d="M114.61,2.4C124,8,145,20.58,145,20.58l-35,17-35-17c.14,0,21.16-12.56,30.59-18.18A8.84,8.84,0,0,1,114.61,2.4Z" fill="#bf97c6" />
<path d="M101,91,51,115.54l50,24.53S100.84,91.21,101,91Z" fill="#652b7c" />
<polygon points="1 140.07 51 115.54 1 91.02 1 140.07" fill="#652b7c" />
<path d="M51,115.54l50,24.53c-.19,0-29.83,18-43.3,26.14a12.48,12.48,0,0,1-12.89,0C31.34,158.1,1,140.07,1,140.07Z" fill="#421540" />
<path d="M57.59,64.79C71.06,72.9,101,91,101,91L51,115.54,1,91c.19,0,30.22-18.12,43.7-26.23A12.48,12.48,0,0,1,57.59,64.79Z" fill="#bf97c6" />
</g>
</g>
</svg>
<span>Opinionated Microservices Framework</span>
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 517 270">
<title>Play Framework</title>
<path d="M36.92,26.44l6.19-6.16a23,23,0,0,1,33.68,1.3l85.77,100a23,23,0,0,1-.22,30.17l-85.5,96.91a23,23,0,0,1-33.49,1.05l-6.17-6.17a23,23,0,0,1-1.4-31l51.16-61.39a23,23,0,0,0,.29-29.08l-52-65A23,23,0,0,1,36.92,26.44Z" fill="#92d13d" />
<path d="M86.94,151.18,35.78,212.57a23,23,0,0,0,1.4,31l6.17,6.17a23,23,0,0,0,33.49-1.05l18.51-21a101.68,101.68,0,0,0,10.89-45.91A101.62,101.62,0,0,0,90,126.54,23,23,0,0,1,86.94,151.18Z" fill="#49691f" />
<path d="M206.64,209.51H186.72V93.81h19.92v12.12c2.82-8.13,13-13.94,26.72-13.94,11.79,0,21.75,4.15,29.72,12.61,8.13,8.3,12.12,18.59,12.12,31s-4,22.75-12.12,31.21c-8,8.3-17.93,12.45-29.72,12.45-13.77,0-23.9-5.81-26.72-13.94Zm5.81-92.13a26.46,26.46,0,0,0,0,36.52,25.42,25.42,0,0,0,18.26,7.31,23.36,23.36,0,0,0,17.59-7.31c4.82-4.81,7.14-11,7.14-18.26s-2.32-13.44-7.14-18.26a23.39,23.39,0,0,0-17.59-7.3A25.46,25.46,0,0,0,212.45,117.38Z" fill="#49691f" />
<path d="M282,61.77h19.92v88.32c0,8.13,2.66,11.62,10,11.62a21.11,21.11,0,0,0,6-.67V178.8a35.53,35.53,0,0,1-9.46,1c-17.6,0-26.4-9-26.4-27.06Z" fill="#49691f" />
<path d="M385.25,105.93V93.81h19.92v58.43c0,7.14,1.66,9.8,6.14,9.8,1.17,0,2.66-.17,4.16-.33v16.1a28.82,28.82,0,0,1-9.8,1.33c-4.81,0-8.63-.83-11.62-2.66a15.41,15.41,0,0,1-6.81-10.13c-5.8,8.8-15.43,13.12-28.71,13.12a39.74,39.74,0,0,1-29.88-12.62c-8-8.46-12-18.76-12-31.21s4-22.74,12-31A39.77,39.77,0,0,1,358.53,92C372,92,382.1,98,385.25,105.93Zm-6,48a24.39,24.39,0,0,0,7.47-18.26,24.42,24.42,0,0,0-7.47-18.26,24.82,24.82,0,0,0-18.1-7.3,24.05,24.05,0,0,0-17.76,7.3c-4.65,4.82-7,11-7,18.26s2.32,13.45,7,18.26a24,24,0,0,0,17.76,7.31A24.79,24.79,0,0,0,379.28,153.9Z" fill="#49691f" />
<path d="M422.36,194.24a29.76,29.76,0,0,0,9.29,1.33,13.13,13.13,0,0,0,7.31-1.83c1.82-1.16,3.48-3.65,4.81-7.13l2.16-6-35-86.82H431l24.57,63.08,23.07-63.08h20.09L461.2,191.09q-3.74,9.71-9,14.94c-5,4.65-11.62,7-20.09,7a34.91,34.91,0,0,1-9.79-1.33Z" fill="#49691f" />
</svg>
<span>High velocity<br> web framework</span>
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 590 270">
<title>Scala</title>
<path d="M200.7,142.39c6,11.79,15.6,17.6,29.05,17.6,14.44,0,19.59-7.64,19.59-15.11,0-5.15-1.83-8.63-6.64-11.79-4.82-3.32-8.3-4.81-16.93-8-10.63-4-16.77-7-23.41-12.29-6.64-5.48-9.79-13-9.79-22.74a28.28,28.28,0,0,1,10.29-22.58c7-5.81,15.44-8.63,25.56-8.63,15.77,0,27.72,6.31,35.69,18.76L249.34,87.78c-4.48-6.81-11.29-10.3-20.59-10.3-9.13,0-15.77,5.15-15.77,12.29,0,4.81,2,7.14,4.82,10,1.82,1.33,6.47,3.32,8.63,4.48l6,2.32,6.8,2.66c11,4.48,18.76,9.3,23.57,14.44s7.31,12.12,7.31,20.75c0,20.42-14.11,34.2-40.51,34.2-21.41,0-37.18-10-44.48-26.4Z" fill="#380d09" />
<path d="M354.25,104.71,342,117.49a28.14,28.14,0,0,0-21.24-9.13,25,25,0,0,0-18.43,7.47,27.76,27.76,0,0,0,0,37.52,25,25,0,0,0,18.43,7.47A28.14,28.14,0,0,0,342,151.69l12.29,12.78c-9,9.63-20.09,14.44-33.53,14.44-12.79,0-23.58-4.15-32.37-12.62s-13.12-19.09-13.12-31.7,4.32-23.08,13.12-31.54,19.58-12.78,32.37-12.78C334.16,90.27,345.28,95.08,354.25,104.71Z" fill="#380d09" />
<path d="M393.88,125.62C408,124.3,413,122.47,413,116c0-5.15-4.64-9.13-13.94-9.13q-13.44,0-22.41,10.95l-12.28-10.46c8.13-11.45,19.58-17.09,34.36-17.09,20.75,0,33.7,10,33.7,27.05v37c0,5.81,2.15,6.48,7,6.48h.5v15.43c-2,1.17-5.15,1.83-9.3,1.83-4.48,0-8-1.33-10.62-4a14.06,14.06,0,0,1-3-5.48c-5.81,6.8-15.27,10.29-28.39,10.29-18.42,0-30.87-10.13-30.87-25.4C357.7,136.41,369.15,127.78,393.88,125.62ZM391.56,162c13.28,0,21.41-6,21.41-16.6v-9.3a9.75,9.75,0,0,1-4.14,2.49c-3.82,1.33-6.31,1.66-14.28,2.49-11.62,1.33-17.43,5-17.43,10.79C377.12,158.33,382.43,162,391.56,162Z" fill="#380d09" />
<path d="M444.84,60.88h19.92V149.2c0,8.13,2.66,11.62,10,11.62a21.15,21.15,0,0,0,6-.67v17.76a35.56,35.56,0,0,1-9.47,1c-17.59,0-26.39-9-26.39-27.06Z" fill="#380d09" />
<path d="M521.71,125.62c14.11-1.32,19.09-3.15,19.09-9.62,0-5.15-4.64-9.13-13.94-9.13q-13.44,0-22.41,10.95l-12.28-10.46c8.13-11.45,19.58-17.09,34.36-17.09,20.75,0,33.7,10,33.7,27.05v37c0,5.81,2.15,6.48,7,6.48h.5v15.43c-2,1.17-5.15,1.83-9.3,1.83-4.48,0-8-1.33-10.62-4a13.94,13.94,0,0,1-3-5.48c-5.81,6.8-15.27,10.29-28.39,10.29-18.42,0-30.87-10.13-30.87-25.4C485.53,136.41,497,127.78,521.71,125.62ZM519.39,162c13.28,0,21.41-6,21.41-16.6v-9.3a9.73,9.73,0,0,1-4.15,2.49c-3.81,1.33-6.3,1.66-14.27,2.49-11.62,1.33-17.43,5-17.43,10.79C505,158.33,510.26,162,519.39,162Z" fill="#380d09" />
<path d="M30.55,94.83C32.4,97.38,48,102.19,71.27,107.2c23.27,4.46,47.47,22.07,66.29,16.64,12.73-3.68,26.54-36.47,26.54-41.34V82c0-3.4-2.55-6.13-6.88-8.4-17.75-9.07-21.11-12.41-27.69-10.6C95.37,72.43,35.06,67.61,30.55,94.83Z" fill="#380d09" fill-rule="evenodd" />
<path d="M30.55,161.41C32.4,164,48,168.77,71.27,173.79c26,4.74,48.61,20.19,67.44,14.75,12.73-3.68,25.39-34.58,25.39-39.46v-.48c0-3.39-2.55-6.13-6.88-8.39-13.54-7.2-31.43-15.13-38-13.32C85,136.3,39.26,138.37,30.55,161.41Z" fill="#380d09" fill-rule="evenodd" />
<path d="M30.36,109.14v.48h0A3.73,3.73,0,0,1,30.36,109.14Z" fill="#555" fill-rule="evenodd" />
<path d="M138.66,28.78C107.2,37.87,57.29,43,30.4,43h0V94.35a.8.8,0,0,0,.19.48c18.35,0,75-6,109.18-15.4a129,129,0,0,0,17.49-5.81c4.18-1.88,6.88-3.86,6.88-5.92V15.91C164.1,20.79,151.39,25.11,138.66,28.78Z" fill="#de3423" fill-rule="evenodd" />
<path d="M138.66,95.37c-18.83,5.43-44.24,9.47-67.39,11.83-15.54,1.59-30.06,2.42-40.87,2.42h0v51.31a.8.8,0,0,0,.19.48c18.35,0,75-6,109.18-15.39a130.38,130.38,0,0,0,17.49-5.81c4.18-1.89,6.88-3.86,6.88-5.92V82.5C164.1,87.37,151.39,91.69,138.66,95.37Z" fill="#de3423" fill-rule="evenodd" />
<path d="M138.66,162c-18.83,5.43-44.24,9.46-67.39,11.83-15.56,1.59-30.1,2.42-40.91,2.42V228c18.16,0,75.1-5.95,109.37-15.39,12.63-3.48,24.37-7.44,24.37-11.74V149.08C164.1,154,151.39,158.28,138.66,162Z" fill="#de3423" fill-rule="evenodd" />
</svg>
<span>The JVM language<br> of pragmatism</span>
</a>
<div class="akka">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 658 270">
<title>Akka</title>
<g id="akka-full-color">
<path d="M349.64,105.46V93.34h19.92v58.44c0,7.13,1.66,9.79,6.14,9.79,1.17,0,2.66-.17,4.15-.33v16.1a28.71,28.71,0,0,1-9.79,1.33c-4.81,0-8.63-.83-11.62-2.66a15.41,15.41,0,0,1-6.81-10.12C345.82,174.68,336.2,179,322.92,179A39.74,39.74,0,0,1,293,166.38c-8-8.46-12-18.75-12-31.2s4-22.75,12-31.05a39.77,39.77,0,0,1,29.88-12.61C336.36,91.52,346.49,97.49,349.64,105.46Zm-6,48a24.42,24.42,0,0,0,7.47-18.26,24.39,24.39,0,0,0-7.47-18.26,24.79,24.79,0,0,0-18.1-7.31,24,24,0,0,0-17.76,7.31c-4.65,4.81-7,11-7,18.26s2.32,13.44,7,18.26a24,24,0,0,0,17.76,7.3A24.82,24.82,0,0,0,343.67,153.44Z" fill="#0b5567" />
<path d="M388.48,177V61.31h19.76v67.56l30.87-35.53H462l-32.7,37.35L465.51,177H442.93l-26.39-33.7-8.3,9.3V177Z" fill="#0b5567" />
<path d="M470.82,177V61.31h19.75v67.56l30.88-35.53h22.91l-32.7,37.35L547.84,177H525.27l-26.4-33.7-8.3,9.3V177Z" fill="#0b5567" />
<path d="M607.87,105.46V93.34h19.92v58.44c0,7.13,1.66,9.79,6.14,9.79,1.17,0,2.66-.17,4.15-.33v16.1a28.71,28.71,0,0,1-9.79,1.33c-4.81,0-8.63-.83-11.62-2.66a15.41,15.41,0,0,1-6.81-10.12c-5.81,8.79-15.43,13.11-28.71,13.11a39.74,39.74,0,0,1-29.88-12.62c-8-8.46-12-18.75-12-31.2s4-22.75,12-31.05a39.77,39.77,0,0,1,29.88-12.61C594.59,91.52,604.72,97.49,607.87,105.46Zm-6,48a24.42,24.42,0,0,0,7.47-18.26,24.39,24.39,0,0,0-7.47-18.26,24.79,24.79,0,0,0-18.1-7.31A24,24,0,0,0,566,116.92c-4.65,4.81-7,11-7,18.26s2.32,13.44,7,18.26a24,24,0,0,0,17.76,7.3A24.82,24.82,0,0,0,601.9,153.44Z" fill="#0b5567" />
<path d="M230.26,212.82c35.88,28.67,58.91-57,1.74-72.82-48-13.29-96.33,9.5-144.66,62.74C87.34,202.74,176.67,170,230.26,212.82Z" fill="#0b5567" />
<path d="M88.08,202c34.41-35.69,91.64-75.53,144.9-60.75A46.09,46.09,0,0,1,259.9,160.6L209.48,58.78c-7.2-11.46-25.58-9.15-35.95-.26L40.29,170.07a27.4,27.4,0,0,0-1.56,40.15l0,0a27.4,27.4,0,0,0,36.51,2L88.14,202Z" fill="#15a9ce" />
</g>
</svg>
<span>Actor-based,<br> cloud native toolkit</span>
</div>
<div class="platform">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Lightbend Platform.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="See Akka In Lightbend Platform [Button]" href="https://www.lightbend.com/akka-part-of-lightbend-platform" target="_blank">See Akka In Lightbend Platform</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.4
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html#interaction-patterns" class="active page">Interaction Patterns</a>
    <ul>
      <li><a href="../typed/interaction-patterns.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/interaction-patterns.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/interaction-patterns.html#fire-and-forget" class="header">Fire and Forget</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response" class="header">Request-Response</a></li>
      <li><a href="../typed/interaction-patterns.html#adapted-response" class="header">Adapted Response</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-between-two-actors" class="header">Request-Response with ask between two actors</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-from-outside-an-actor" class="header">Request-Response with ask from outside an Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#ignoring-replies" class="header">Ignoring replies</a></li>
      <li><a href="../typed/interaction-patterns.html#send-future-result-to-self" class="header">Send Future result to self</a></li>
      <li><a href="../typed/interaction-patterns.html#per-session-child-actor" class="header">Per session child Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#general-purpose-response-aggregator" class="header">General purpose response aggregator</a></li>
      <li><a href="../typed/interaction-patterns.html#latency-tail-chopping" class="header">Latency tail chopping</a></li>
      <li><a href="../typed/interaction-patterns.html#scheduling-messages-to-self" class="header">Scheduling messages to self</a></li>
      <li><a href="../typed/interaction-patterns.html#responding-to-a-sharded-actor" class="header">Responding to a sharded actor</a></li>
    </ul></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html" class="page">Learning Akka Typed from Classic</a></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.4
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html#interaction-patterns" class="active page">Interaction Patterns</a>
    <ul>
      <li><a href="../typed/interaction-patterns.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/interaction-patterns.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/interaction-patterns.html#fire-and-forget" class="header">Fire and Forget</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response" class="header">Request-Response</a></li>
      <li><a href="../typed/interaction-patterns.html#adapted-response" class="header">Adapted Response</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-between-two-actors" class="header">Request-Response with ask between two actors</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-from-outside-an-actor" class="header">Request-Response with ask from outside an Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#ignoring-replies" class="header">Ignoring replies</a></li>
      <li><a href="../typed/interaction-patterns.html#send-future-result-to-self" class="header">Send Future result to self</a></li>
      <li><a href="../typed/interaction-patterns.html#per-session-child-actor" class="header">Per session child Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#general-purpose-response-aggregator" class="header">General purpose response aggregator</a></li>
      <li><a href="../typed/interaction-patterns.html#latency-tail-chopping" class="header">Latency tail chopping</a></li>
      <li><a href="../typed/interaction-patterns.html#scheduling-messages-to-self" class="header">Scheduling messages to self</a></li>
      <li><a href="../typed/interaction-patterns.html#responding-to-a-sharded-actor" class="header">Responding to a sharded actor</a></li>
    </ul></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html" class="page">Learning Akka Typed from Classic</a></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#interaction-patterns" name="interaction-patterns" class="anchor"><span class="anchor-link"></span></a>Interaction Patterns</h1>
<p>For the Akka Classic documentation of this feature see <a href="../actors.html">Classic Actors</a>.</p>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Actor Typed, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor-typed" % "2.6.4"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor-typed_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.6.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor-typed_2.12', version: '2.6.4'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Interacting with an Actor in Akka is done through an <span class="group-scala"><code>ActorRef[T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> where <code>T</code> is the type of messages the actor accepts, also known as the &ldquo;protocol&rdquo;. This ensures that only the right kind of messages can be sent to an actor and also that no one else but the Actor itself can access the Actor instance internals.</p>
<p>Message exchange with Actors follow a few common patterns, let&rsquo;s go through each one of them. </p>
<h2><a href="#fire-and-forget" name="fire-and-forget" class="anchor"><span class="anchor-link"></span></a>Fire and Forget</h2>
<p>The fundamental way to interact with an actor is through <span class="group-scala">&ldquo;tell&rdquo;, which is so common that it has a special symbolic method name: <code>actorRef ! message</code></span><span class="group-java"><code>actorRef.tell(message)</code></span>. Sending a message with tell can safely be done from any thread.</p>
<p>Tell is asynchronous which means that the method returns right away. After the statement is executed there is no guarantee that the message has been processed by the recipient yet. It also means there is no way to know if the message was received, the processing succeeded or failed.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/fire-forget.png" alt="fire-forget.png" /></p>
<p>With the given protocol and actor behavior:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L31-L41" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Printer {

  case class PrintMe(message: String)

  def apply(): Behavior[PrintMe] =
    Behaviors.receive {
      case (context, PrintMe(message)) =&gt;
        context.log.info(message)
        Behaviors.same
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L35-L56" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Printer {
  public static class PrintMe {
    public final String message;

    public PrintMe(String message) {
      this.message = message;
    }
  }

  public static Behavior&lt;PrintMe&gt; create() {
    return Behaviors.setup(
        context -&gt;
            Behaviors.receive(PrintMe.class)
                .onMessage(
                    PrintMe.class,
                    printMe -&gt; {
                      context.getLog().info(printMe.message);
                      return Behaviors.same();
                    })
                .build());
  }
}</code></pre></dd>
</dl>
<p>Fire and forget looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L45-L52" target="_blank" title="Go to snippet source"></a><code class="language-scala">val system = ActorSystem(Printer(), &quot;fire-and-forget-sample&quot;)

// note how the system is also the top level actor ref
val printer: ActorRef[Printer.PrintMe] = system

// these are all fire and forget
printer ! Printer.PrintMe(&quot;message 1&quot;)
printer ! Printer.PrintMe(&quot;not message 2&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L875-L883" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem&lt;Printer.PrintMe&gt; system =
    ActorSystem.create(Printer.create(), &quot;printer-sample-system&quot;);

// note that system is also the ActorRef to the guardian actor
final ActorRef&lt;Printer.PrintMe&gt; ref = system;

// these are all fire and forget
ref.tell(new Printer.PrintMe(&quot;message 1&quot;));
ref.tell(new Printer.PrintMe(&quot;message 2&quot;));</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>It is not critical to be sure that the message was processed</li>
  <li>There is no way to act on non successful delivery or processing</li>
  <li>We want to minimize the number of messages created to get higher throughput (sending a response would require creating twice the number of messages)</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>If the inflow of messages is higher than the actor can process the inbox will fill up and can in the worst case cause the JVM crash with an <code>OutOfMemoryError</code></li>
  <li>If the message gets lost, the sender will not know</li>
</ul>
<h2><a href="#request-response" name="request-response" class="anchor"><span class="anchor-link"></span></a>Request-Response</h2>
<p>Many interactions between actors require one or more response message being sent back from the receiving actor. A response message can be a result of a query, some form of acknowledgment that the message was received and processed or events that the request subscribed to.</p>
<p>In Akka the recipient of responses has to be encoded as a field in the message itself, which the recipient can then use to send (tell) a response back.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/request-response.png" alt="request-response.png" /></p>
<p>With the following protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L63-L64" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class Request(query: String, replyTo: ActorRef[Response])
case class Response(result: String)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L61-L77" target="_blank" title="Go to snippet source"></a><code class="language-java">public static class Request {
  public final String query;
  public final ActorRef&lt;Response&gt; replyTo;

  public Request(String query, ActorRef&lt;Response&gt; replyTo) {
    this.query = query;
    this.replyTo = replyTo;
  }
}

public static class Response {
  public final String result;

  public Response(String result) {
    this.result = result;
  }
}</code></pre></dd>
</dl>
<p>The sender would use its own <span class="group-scala"><code>ActorRef[Response]</code></span><span class="group-java"><code>ActorRef&lt;Response&gt;</code></span>, which it can access through <span class="group-scala"><code>ActorContext.self</code></span><span class="group-java"><code>ActorContext.getSelf()</code></span>, for the <code>replyTo</code>. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L87" target="_blank" title="Go to snippet source"></a><code class="language-scala">cookieFabric ! CookieFabric.Request(&quot;give me cookies&quot;, context.self)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L100" target="_blank" title="Go to snippet source"></a><code class="language-java">cookieFabric.tell(new CookieFabric.Request(&quot;give me cookies&quot;, context.getSelf()));</code></pre></dd>
</dl>
<p>On the receiving side the <span class="group-scala"><code>ActorRef[Response]</code></span><span class="group-java"><code>ActorRef&lt;Response&gt;</code></span> can then be used to send one or more responses back:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L68-L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">def apply(): Behaviors.Receive[Request] =
  Behaviors.receiveMessage[Request] {
    case Request(query, replyTo) =&gt;
      // ... process query ...
      replyTo ! Response(s&quot;Here are the cookies for [$query]!&quot;)
      Behaviors.same
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L81-L92" target="_blank" title="Go to snippet source"></a><code class="language-java">// actor behavior
public static Behavior&lt;Request&gt; create() {
  return Behaviors.receive(Request.class)
      .onMessage(Request.class, CookieFabric::onRequest)
      .build();
}

private static Behavior&lt;Request&gt; onRequest(Request request) {
  // ... process request ...
  request.replyTo.tell(new Response(&quot;Here are the cookies for &quot; + request.query));
  return Behaviors.same();
}</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Subscribing to an actor that will send many response messages back</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Actors seldom have a response message from another actor as a part of their protocol (see <a href="interaction-patterns.html#adapted-response">adapted response</a>)</li>
  <li>It is hard to detect that a message request was not delivered or processed (see <a href="interaction-patterns.html#request-response-with-ask-between-two-actors">ask</a>)</li>
  <li>Unless the protocol already includes a way to provide context, for example a request id that is also sent in the  response, it is not possible to tie an interaction to some specific context without introducing a new,  separate, actor (see <a href="interaction-patterns.html#request-response-with-ask-between-two-actors">ask</a> or <a href="interaction-patterns.html#per-session-child-actor">per session child actor</a>)</li>
</ul>
<h2><a href="#adapted-response" name="adapted-response" class="anchor"><span class="anchor-link"></span></a>Adapted Response</h2>
<p>Most often the sending actor does not, and should not, support receiving the response messages of another actor. In such cases we need to provide an <code>ActorRef</code> of the right type and adapt the response message to a type that the sending actor can handle.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/adapted-response.png" alt="adapted-response.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L102-L149" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>object Backend {
  sealed trait Request
  final case class StartTranslationJob(taskId: Int, site: URI, replyTo: ActorRef[Response]) extends Request

  sealed trait Response
  final case class JobStarted(taskId: Int) extends Response
  final case class JobProgress(taskId: Int, progress: Double) extends Response
  final case class JobCompleted(taskId: Int, result: URI) extends Response
}

object Frontend {

  sealed trait Command
  final case class Translate(site: URI, replyTo: ActorRef[URI]) extends Command
  private final case class WrappedBackendResponse(response: Backend.Response) extends Command

  def apply(backend: ActorRef[Backend.Request]): Behavior[Command] =
    Behaviors.setup[Command] { context =&gt;
      val backendResponseMapper: ActorRef[Backend.Response] =
        context.messageAdapter(rsp =&gt; WrappedBackendResponse(rsp))

      def active(inProgress: Map[Int, ActorRef[URI]], count: Int): Behavior[Command] = {
        Behaviors.receiveMessage[Command] {
          case Translate(site, replyTo) =&gt;
            val taskId = count + 1
            backend ! Backend.StartTranslationJob(taskId, site, backendResponseMapper)
            active(inProgress.updated(taskId, replyTo), taskId)

          case wrapped: WrappedBackendResponse =&gt;
            wrapped.response match {
              case Backend.JobStarted(taskId) =&gt;
                context.log.info(&quot;Started {}&quot;, taskId)
                Behaviors.same
              case Backend.JobProgress(taskId, progress) =&gt;
                context.log.info2(&quot;Progress {}: {}&quot;, taskId, progress)
                Behaviors.same
              case Backend.JobCompleted(taskId, result) =&gt;
                context.log.info2(&quot;Completed {}: {}&quot;, taskId, result)
                inProgress(taskId) ! result
                active(inProgress - taskId, count)
            }
        }
      }

      active(inProgress = Map.empty, count = 0)
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L111-L230" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>public class Backend {
  public interface Request {}

  public static class StartTranslationJob implements Request {
    public final int taskId;
    public final URI site;
    public final ActorRef&lt;Response&gt; replyTo;

    public StartTranslationJob(int taskId, URI site, ActorRef&lt;Response&gt; replyTo) {
      this.taskId = taskId;
      this.site = site;
      this.replyTo = replyTo;
    }
  }

  public interface Response {}

  public static class JobStarted implements Response {
    public final int taskId;

    public JobStarted(int taskId) {
      this.taskId = taskId;
    }
  }

  public static class JobProgress implements Response {
    public final int taskId;
    public final double progress;

    public JobProgress(int taskId, double progress) {
      this.taskId = taskId;
      this.progress = progress;
    }
  }

  public static class JobCompleted implements Response {
    public final int taskId;
    public final URI result;

    public JobCompleted(int taskId, URI result) {
      this.taskId = taskId;
      this.result = result;
    }
  }
}

public class Frontend {

  public interface Command {}

  public static class Translate implements Command {
    public final URI site;
    public final ActorRef&lt;URI&gt; replyTo;

    public Translate(URI site, ActorRef&lt;URI&gt; replyTo) {
      this.site = site;
      this.replyTo = replyTo;
    }
  }

  private static class WrappedBackendResponse implements Command {
    final Backend.Response response;

    public WrappedBackendResponse(Backend.Response response) {
      this.response = response;
    }
  }

  public static class Translator extends AbstractBehavior&lt;Command&gt; {
    private final ActorRef&lt;Backend.Request&gt; backend;
    private final ActorRef&lt;Backend.Response&gt; backendResponseAdapter;

    private int taskIdCounter = 0;
    private Map&lt;Integer, ActorRef&lt;URI&gt;&gt; inProgress = new HashMap&lt;&gt;();

    public Translator(ActorContext&lt;Command&gt; context, ActorRef&lt;Backend.Request&gt; backend) {
      super(context);
      this.backend = backend;
      this.backendResponseAdapter =
          context.messageAdapter(Backend.Response.class, WrappedBackendResponse::new);
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(Translate.class, this::onTranslate)
          .onMessage(WrappedBackendResponse.class, this::onWrappedBackendResponse)
          .build();
    }

    private Behavior&lt;Command&gt; onTranslate(Translate cmd) {
      taskIdCounter += 1;
      inProgress.put(taskIdCounter, cmd.replyTo);
      backend.tell(
          new Backend.StartTranslationJob(taskIdCounter, cmd.site, backendResponseAdapter));
      return this;
    }

    private Behavior&lt;Command&gt; onWrappedBackendResponse(WrappedBackendResponse wrapped) {
      Backend.Response response = wrapped.response;
      if (response instanceof Backend.JobStarted) {
        Backend.JobStarted rsp = (Backend.JobStarted) response;
        getContext().getLog().info(&quot;Started {}&quot;, rsp.taskId);
      } else if (response instanceof Backend.JobProgress) {
        Backend.JobProgress rsp = (Backend.JobProgress) response;
        getContext().getLog().info(&quot;Progress {}&quot;, rsp.taskId);
      } else if (response instanceof Backend.JobCompleted) {
        Backend.JobCompleted rsp = (Backend.JobCompleted) response;
        getContext().getLog().info(&quot;Completed {}&quot;, rsp.taskId);
        inProgress.get(rsp.taskId).tell(rsp.result);
        inProgress.remove(rsp.taskId);
      } else {
        return Behaviors.unhandled();
      }

      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>You can register several message adapters for different message classes. It&rsquo;s only possible to have one message adapter per message class to make sure that the number of adapters are not growing unbounded if registered repeatedly. That also means that a registered adapter will replace an existing adapter for the same message class.</p>
<p>A message adapter will be used if the message class matches the given class or is a subclass thereof. The registered adapters are tried in reverse order of their registration order, i.e. the last registered first.</p>
<p>A message adapter (and the returned <code>ActorRef</code>) has the same lifecycle as the receiving actor. It&rsquo;s recommended to register the adapters in a top level <code>Behaviors.setup</code> or constructor of <code>AbstractBehavior</code> but it&rsquo;s possible to register them later if needed.</p>
<p>The adapter function is running in the receiving actor and can safely access its state, but if it throws an exception the actor is stopped.</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Translating between different actor message protocols</li>
  <li>Subscribing to an actor that will send many response messages back</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>It is hard to detect that a message request was not delivered or processed (see <a href="interaction-patterns.html#request-response-with-ask-between-two-actors">ask</a>)</li>
  <li>Only one adaption can be made per response message type, if a new one is registered the old one is replaced,  for example different target actors can&rsquo;t have different adaption if they use the same response types, unless some  correlation is encoded in the messages</li>
  <li>Unless the protocol already includes a way to provide context, for example a request id that is also sent in the  response, it is not possible to tie an interaction to some specific context without introducing a new,  separate, actor</li>
</ul>
<h2><a href="#request-response-with-ask-between-two-actors" name="request-response-with-ask-between-two-actors" class="anchor"><span class="anchor-link"></span></a>Request-Response with ask between two actors</h2>
<p>In an interaction where there is a 1:1 mapping between a request and a response we can use <code>ask</code> on the <code>ActorContext</code> to interact with another actor.</p>
<p>The interaction has two steps, first we need to construct the outgoing message, to do that we need an <span class="group-scala"><code>ActorRef[Response]</code></span><span class="group-java"><code>ActorRef&lt;Response&gt;</code></span> to put as recipient in the outgoing message. The second step is to transform the successful <code>Response</code> or failure into a message that is part of the protocol of the sending actor.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/ask-from-actor.png" alt="ask-from-actor.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L232-L284" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Hal {
  sealed trait Command
  case class OpenThePodBayDoorsPlease(replyTo: ActorRef[Response]) extends Command
  case class Response(message: String)

  def apply(): Behaviors.Receive[Hal.Command] =
    Behaviors.receiveMessage[Command] {
      case OpenThePodBayDoorsPlease(replyTo) =&gt;
        replyTo ! Response(&quot;I&#39;m sorry, Dave. I&#39;m afraid I can&#39;t do that.&quot;)
        Behaviors.same
    }
}

object Dave {

  sealed trait Command
  // this is a part of the protocol that is internal to the actor itself
  private case class AdaptedResponse(message: String) extends Command

  def apply(hal: ActorRef[Hal.Command]): Behavior[Dave.Command] =
    Behaviors.setup[Command] { context =&gt;
      // asking someone requires a timeout, if the timeout hits without response
      // the ask is failed with a TimeoutException
      implicit val timeout: Timeout = 3.seconds

      // Note: The second parameter list takes a function `ActorRef[T] =&gt; Message`,
      // as OpenThePodBayDoorsPlease is a case class it has a factory apply method
      // that is what we are passing as the second parameter here it could also be written
      // as `ref =&gt; OpenThePodBayDoorsPlease(ref)`
      context.ask(hal, Hal.OpenThePodBayDoorsPlease) {
        case Success(Hal.Response(message)) =&gt; AdaptedResponse(message)
        case Failure(_)                     =&gt; AdaptedResponse(&quot;Request failed&quot;)
      }

      // we can also tie in request context into an interaction, it is safe to look at
      // actor internal state from the transformation function, but remember that it may have
      // changed at the time the response arrives and the transformation is done, best is to
      // use immutable state we have closed over like here.
      val requestId = 1
      context.ask(hal, Hal.OpenThePodBayDoorsPlease) {
        case Success(Hal.Response(message)) =&gt; AdaptedResponse(s&quot;$requestId: $message&quot;)
        case Failure(_)                     =&gt; AdaptedResponse(s&quot;$requestId: Request failed&quot;)
      }

      Behaviors.receiveMessage {
        // the adapted message ends up being processed like any other
        // message sent to the actor
        case AdaptedResponse(message) =&gt;
          context.log.info(&quot;Got response from hal: {}&quot;, message)
          Behaviors.same
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L342-L456" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Hal extends AbstractBehavior&lt;Hal.Command&gt; {

  public Behavior&lt;Hal.Command&gt; create() {
    return Behaviors.setup(Hal::new);
  }

  private Hal(ActorContext&lt;Command&gt; context) {
    super(context);
  }

  public interface Command {}

  public static final class OpenThePodBayDoorsPlease implements Command {
    public final ActorRef&lt;HalResponse&gt; respondTo;

    public OpenThePodBayDoorsPlease(ActorRef&lt;HalResponse&gt; respondTo) {
      this.respondTo = respondTo;
    }
  }

  public static final class HalResponse {
    public final String message;

    public HalResponse(String message) {
      this.message = message;
    }
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(OpenThePodBayDoorsPlease.class, this::onOpenThePodBayDoorsPlease)
        .build();
  }

  private Behavior&lt;Command&gt; onOpenThePodBayDoorsPlease(OpenThePodBayDoorsPlease message) {
    message.respondTo.tell(new HalResponse(&quot;I&#39;m sorry, Dave. I&#39;m afraid I can&#39;t do that.&quot;));
    return this;
  }
}

public class Dave extends AbstractBehavior&lt;Dave.Command&gt; {

  public interface Command {}

  // this is a part of the protocol that is internal to the actor itself
  private static final class AdaptedResponse implements Command {
    public final String message;

    public AdaptedResponse(String message) {
      this.message = message;
    }
  }

  public static Behavior&lt;Command&gt; create(ActorRef&lt;Hal.Command&gt; hal) {
    return Behaviors.setup(context -&gt; new Dave(context, hal));
  }

  private Dave(ActorContext&lt;Command&gt; context, ActorRef&lt;Hal.Command&gt; hal) {
    super(context);

    // asking someone requires a timeout, if the timeout hits without response
    // the ask is failed with a TimeoutException
    final Duration timeout = Duration.ofSeconds(3);

    context.ask(
        Hal.HalResponse.class,
        hal,
        timeout,
        // construct the outgoing message
        (ActorRef&lt;Hal.HalResponse&gt; ref) -&gt; new Hal.OpenThePodBayDoorsPlease(ref),
        // adapt the response (or failure to respond)
        (response, throwable) -&gt; {
          if (response != null) {
            return new AdaptedResponse(response.message);
          } else {
            return new AdaptedResponse(&quot;Request failed&quot;);
          }
        });

    // we can also tie in request context into an interaction, it is safe to look at
    // actor internal state from the transformation function, but remember that it may have
    // changed at the time the response arrives and the transformation is done, best is to
    // use immutable state we have closed over like here.
    final int requestId = 1;
    context.ask(
        Hal.HalResponse.class,
        hal,
        timeout,
        // construct the outgoing message
        (ActorRef&lt;Hal.HalResponse&gt; ref) -&gt; new Hal.OpenThePodBayDoorsPlease(ref),
        // adapt the response (or failure to respond)
        (response, throwable) -&gt; {
          if (response != null) {
            return new AdaptedResponse(requestId + &quot;: &quot; + response.message);
          } else {
            return new AdaptedResponse(requestId + &quot;: Request failed&quot;);
          }
        });
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        // the adapted message ends up being processed like any other
        // message sent to the actor
        .onMessage(AdaptedResponse.class, this::onAdaptedResponse)
        .build();
  }

  private Behavior&lt;Command&gt; onAdaptedResponse(AdaptedResponse response) {
    getContext().getLog().info(&quot;Got response from HAL: {}&quot;, response.message);
    return this;
  }
}</code></pre></dd>
</dl>
<p>The response adapting function is running in the receiving actor and can safely access its state, but if it throws an exception the actor is stopped.</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Single response queries</li>
  <li>An actor needs to know that the message was processed before continuing</li>
  <li>To allow an actor to resend if a timely response is not produced</li>
  <li>To keep track of outstanding requests and not overwhelm a recipient with messages (&ldquo;backpressure&rdquo;)</li>
  <li>Context should be attached to the interaction but the protocol does not support that (request id, what query the response was for)</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>There can only be a single response to one <code>ask</code> (see <a href="interaction-patterns.html#per-session-child-actor">per session child Actor</a>)</li>
  <li>When <code>ask</code> times out, the receiving actor does not know and may still process it to completion, or even start processing it after the fact</li>
  <li>Finding a good value for the timeout, especially when <code>ask</code> triggers chained <code>ask</code>s in the receiving actor. You want a short timeout to be responsive and answer back to the requester, but at the same time you do not want to have many false positives</li>
</ul>
<a id="outside-ask"></a>
<h2><a href="#request-response-with-ask-from-outside-an-actor" name="request-response-with-ask-from-outside-an-actor" class="anchor"><span class="anchor-link"></span></a>Request-Response with ask from outside an Actor</h2>
<p>Sometimes you need to interact with actors from the outside of the actor system, this can be done with fire-and-forget as described above or through another version of <code>ask</code> that returns a <span class="group-scala"><code>Future[Response]</code></span><span class="group-java"><code>CompletionStage&lt;Response&gt;</code></span> that is either completed with a successful response or failed with a <code>TimeoutException</code> if there was no response within the specified timeout.</p>
<p>To do this we use <span class="group-scala"><code>ActorRef.ask</code> (or the symbolic <code>ActorRef.?</code>) implicitly provided by <code>akka.actor.typed.scaladsl.AskPattern</code></span><span class="group-java"><code>akka.actor.typed.javadsl.AskPattern.ask</code></span> to send a message to an actor and get a <span class="group-scala"><code>Future[Response]</code></span><span class="group-java"><code>CompletionState[Response]</code></span> back.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/ask-from-outside.png" alt="ask-from-outside.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L399-L439" target="_blank" title="Go to snippet source"></a><code class="language-scala">object CookieFabric {
  sealed trait Command {}
  case class GiveMeCookies(count: Int, replyTo: ActorRef[Reply]) extends Command

  sealed trait Reply
  case class Cookies(count: Int) extends Reply
  case class InvalidRequest(reason: String) extends Reply

  def apply(): Behaviors.Receive[CookieFabric.GiveMeCookies] =
    Behaviors.receiveMessage { message =&gt;
      if (message.count &gt;= 5)
        message.replyTo ! InvalidRequest(&quot;Too many cookies.&quot;)
      else
        message.replyTo ! Cookies(message.count)
      Behaviors.same
    }
}

import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout

// asking someone requires a timeout if the timeout hits without response
// the ask is failed with a TimeoutException
implicit val timeout: Timeout = 3.seconds

val result: Future[CookieFabric.Reply] = cookieFabric.ask(ref =&gt; CookieFabric.GiveMeCookies(3, ref))

// the response callback will be executed on this execution context
implicit val ec = system.executionContext

result.onComplete {
  case Success(CookieFabric.Cookies(count))         =&gt; println(s&quot;Yay, $count cookies!&quot;)
  case Success(CookieFabric.InvalidRequest(reason)) =&gt; println(s&quot;No cookies for me. $reason&quot;)
  case Failure(ex)                                  =&gt; println(s&quot;Boo! didn&#39;t get cookies: ${ex.getMessage}&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L628-L706" target="_blank" title="Go to snippet source"></a><code class="language-java">public class CookieFabric extends AbstractBehavior&lt;CookieFabric.Command&gt; {

  interface Command {}

  public static class GiveMeCookies implements Command {
    public final int count;
    public final ActorRef&lt;Reply&gt; replyTo;

    public GiveMeCookies(int count, ActorRef&lt;Reply&gt; replyTo) {
      this.count = count;
      this.replyTo = replyTo;
    }
  }

  interface Reply {}

  public static class Cookies implements Reply {
    public final int count;

    public Cookies(int count) {
      this.count = count;
    }
  }

  public static class InvalidRequest implements Reply {
    public final String reason;

    public InvalidRequest(String reason) {
      this.reason = reason;
    }
  }

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(CookieFabric::new);
  }

  private CookieFabric(ActorContext&lt;Command&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder().onMessage(GiveMeCookies.class, this::onGiveMeCookies).build();
  }

  private Behavior&lt;Command&gt; onGiveMeCookies(GiveMeCookies request) {
    if (request.count &gt;= 5) request.replyTo.tell(new InvalidRequest(&quot;Too many cookies.&quot;));
    else request.replyTo.tell(new Cookies(request.count));

    return this;
  }
}

  public void askAndPrint(
      ActorSystem&lt;Void&gt; system, ActorRef&lt;CookieFabric.Command&gt; cookieFabric) {
    CompletionStage&lt;CookieFabric.Reply&gt; result =
        AskPattern.ask(
            cookieFabric,
            replyTo -&gt; new CookieFabric.GiveMeCookies(3, replyTo),
            // asking someone requires a timeout and a scheduler, if the timeout hits without
            // response the ask is failed with a TimeoutException
            Duration.ofSeconds(3),
            system.scheduler());

    result.whenComplete(
        (reply, failure) -&gt; {
          if (reply instanceof CookieFabric.Cookies)
            System.out.println(&quot;Yay, &quot; + ((CookieFabric.Cookies) reply).count + &quot; cookies!&quot;);
          else if (reply instanceof CookieFabric.InvalidRequest)
            System.out.println(
                &quot;No cookies for me. &quot; + ((CookieFabric.InvalidRequest) reply).reason);
          else System.out.println(&quot;Boo! didn&#39;t get cookies in time. &quot; + failure);
        });
  }</code></pre></dd>
</dl>
<p>Note that validation errors are also explicit in the message protocol. The <code>GiveMeCookies</code> request can reply with <code>Cookies</code> or <code>InvalidRequest</code>. The requestor has to decide how to handle an <code>InvalidRequest</code> reply. Sometimes it should be treated as a failed <span class="group-scala"><code>Future</code></span><span class="group-java"><code>Future</code></span> and for that the reply can be mapped on the requestor side.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L445-L454" target="_blank" title="Go to snippet source"></a><code class="language-scala">val cookies: Future[CookieFabric.Cookies] =
  cookieFabric.ask[CookieFabric.Reply](ref =&gt; CookieFabric.GiveMeCookies(3, ref)).flatMap {
    case c: CookieFabric.Cookies             =&gt; Future.successful(c)
    case CookieFabric.InvalidRequest(reason) =&gt; Future.failed(new IllegalArgumentException(reason))
  }

cookies.onComplete {
  case Success(CookieFabric.Cookies(count)) =&gt; println(s&quot;Yay, $count cookies!&quot;)
  case Failure(ex)                          =&gt; println(s&quot;Boo! didn&#39;t get cookies: ${ex.getMessage}&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L712-L738" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletionStage&lt;CookieFabric.Reply&gt; result =
    AskPattern.ask(
        cookieFabric,
        replyTo -&gt; new CookieFabric.GiveMeCookies(3, replyTo),
        Duration.ofSeconds(3),
        system.scheduler());

CompletionStage&lt;CookieFabric.Cookies&gt; cookies =
    result.thenCompose(
        (CookieFabric.Reply reply) -&gt; {
          if (reply instanceof CookieFabric.Cookies) {
            return CompletableFuture.completedFuture((CookieFabric.Cookies) reply);
          } else if (reply instanceof CookieFabric.InvalidRequest) {
            CompletableFuture&lt;CookieFabric.Cookies&gt; failed = new CompletableFuture&lt;&gt;();
            failed.completeExceptionally(
                new IllegalArgumentException(((CookieFabric.InvalidRequest) reply).reason));
            return failed;
          } else {
            throw new IllegalStateException(&quot;Unexpected reply: &quot; + reply.getClass());
          }
        });

cookies.whenComplete(
    (cookiesReply, failure) -&gt; {
      if (cookies != null) System.out.println(&quot;Yay, &quot; + cookiesReply.count + &quot; cookies!&quot;);
      else System.out.println(&quot;Boo! didn&#39;t get cookies in time. &quot; + failure);
    });</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Querying an actor from outside of the actor system</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>It is easy to accidentally close over and unsafely mutable state with the callbacks on the returned <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> as those will be executed on a different thread</li>
  <li>There can only be a single response to one <code>ask</code> (see <a href="interaction-patterns.html#per-session-child-actor">per session child Actor</a>)</li>
  <li>When <code>ask</code> times out, the receiving actor does not know and may still process it to completion, or even start processing it after the fact</li>
</ul>
<h2><a href="#ignoring-replies" name="ignoring-replies" class="anchor"><span class="anchor-link"></span></a>Ignoring replies</h2>
<p>In some situations an actor has a response for a particular request message but you are not interested in the response. In this case you can pass <span class="group-scala"><code>system.ignoreRef</code></span><span class="group-java"><code>system.ignoreRef()</code></span> turning the request-response into a fire-and-forget.</p>
<p><span class="group-scala"><code>system.ignoreRef</code></span><span class="group-java"><code>system.ignoreRef()</code></span>, as the name indicates, returns an <code>ActorRef</code> that ignores any message sent to it.</p>
<p>With the same protocol as the <a href="interaction-patterns.html#request-response">request response</a> above, if the sender would prefer to ignore the reply it could pass <span class="group-scala"><code>system.ignoreRef</code></span><span class="group-java"><code>system.ignoreRef()</code></span> for the <code>replyTo</code>, which it can access through <span class="group-scala"><code>ActorContext.system.ignoreRef</code></span><span class="group-java"><code>ActorContext.getSystem().ignoreRef()</code></span>. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L94" target="_blank" title="Go to snippet source"></a><code class="language-scala">cookieFabric ! CookieFabric.Request(&quot;don&#39;t send cookies back&quot;, context.system.ignoreRef)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L104-L105" target="_blank" title="Go to snippet source"></a><code class="language-java">cookieFabric.tell(
    new CookieFabric.Request(&quot;don&#39;t send cookies back&quot;, context.getSystem().ignoreRef()));</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Sending a message for which the protocol defines a reply, but you are not interested in getting the reply</li>
</ul>
<p><strong>Problems:</strong></p>
<p>The returned <code>ActorRef</code> ignores all messages sent to it, therefore it should be used carefully.  * Passing it around inadvertently as if it was a normal <code>ActorRef</code> may result in broken actor-to-actor interactions.  * Using it when performing an <code>ask</code> from outside the Actor System will cause the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> returned by the <code>ask</code> to timeout since it will never complete.  * Finally, it&rsquo;s legal to <code>watch</code> it, but since it&rsquo;s of a special kind, it never terminates and therefore you will never receive a <code>Terminated</code> signal from it.</p>
<h2><a href="#send-future-result-to-self" name="send-future-result-to-self" class="anchor"><span class="anchor-link"></span></a>Send Future result to self</h2>
<p>When using an API that returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> from an actor it&rsquo;s common that you would like to use the value of the response in the actor when the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> is completed. For this purpose the <code>ActorContext</code> provides a <code>pipeToSelf</code> method.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/pipe-to-self.png" alt="pipe-to-self.png" /></p>
<p>An actor, <code>CustomerRepository</code>, is invoking a method on <code>CustomerDataAccess</code> that returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L462-L511" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>trait CustomerDataAccess {
  def update(value: Customer): Future[Done]
}

final case class Customer(id: String, version: Long, name: String, address: String)

object CustomerRepository {
  sealed trait Command

  final case class Update(value: Customer, replyTo: ActorRef[UpdateResult]) extends Command
  sealed trait UpdateResult
  final case class UpdateSuccess(id: String) extends UpdateResult
  final case class UpdateFailure(id: String, reason: String) extends UpdateResult
  private final case class WrappedUpdateResult(result: UpdateResult, replyTo: ActorRef[UpdateResult])
      extends Command

  private val MaxOperationsInProgress = 10

  def apply(dataAccess: CustomerDataAccess): Behavior[Command] = {
    next(dataAccess, operationsInProgress = 0)
  }

  private def next(dataAccess: CustomerDataAccess, operationsInProgress: Int): Behavior[Command] = {
    Behaviors.receive { (context, command) =&gt;
      command match {
        case Update(value, replyTo) =&gt;
          if (operationsInProgress == MaxOperationsInProgress) {
            replyTo ! UpdateFailure(value.id, s&quot;Max $MaxOperationsInProgress concurrent operations supported&quot;)
            Behaviors.same
          } else {
            val futureResult = dataAccess.update(value)
            context.pipeToSelf(futureResult) {
              // map the Future value to a message, handled by this actor
              case Success(_) =&gt; WrappedUpdateResult(UpdateSuccess(value.id), replyTo)
              case Failure(e) =&gt; WrappedUpdateResult(UpdateFailure(value.id, e.getMessage), replyTo)
            }
            // increase operationsInProgress counter
            next(dataAccess, operationsInProgress + 1)
          }

        case WrappedUpdateResult(result, replyTo) =&gt;
          // send result to original requestor
          replyTo ! result
          // decrease operationsInProgress counter
          next(dataAccess, operationsInProgress - 1)
      }
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L746-L863" target="_blank" title="Go to snippet source"></a><code class="language-java">public interface CustomerDataAccess {
  CompletionStage&lt;Done&gt; update(Customer customer);
}

public class Customer {
  public final String id;
  public final long version;
  public final String name;
  public final String address;

  public Customer(String id, long version, String name, String address) {
    this.id = id;
    this.version = version;
    this.name = name;
    this.address = address;
  }
}

public class CustomerRepository extends AbstractBehavior&lt;CustomerRepository.Command&gt; {

  private static final int MAX_OPERATIONS_IN_PROGRESS = 10;

  interface Command {}

  public static class Update implements Command {
    public final Customer customer;
    public final ActorRef&lt;OperationResult&gt; replyTo;

    public Update(Customer customer, ActorRef&lt;OperationResult&gt; replyTo) {
      this.customer = customer;
      this.replyTo = replyTo;
    }
  }

  interface OperationResult {}

  public static class UpdateSuccess implements OperationResult {
    public final String id;

    public UpdateSuccess(String id) {
      this.id = id;
    }
  }

  public static class UpdateFailure implements OperationResult {
    public final String id;
    public final String reason;

    public UpdateFailure(String id, String reason) {
      this.id = id;
      this.reason = reason;
    }
  }

  private static class WrappedUpdateResult implements Command {
    public final OperationResult result;
    public final ActorRef&lt;OperationResult&gt; replyTo;

    private WrappedUpdateResult(OperationResult result, ActorRef&lt;OperationResult&gt; replyTo) {
      this.result = result;
      this.replyTo = replyTo;
    }
  }

  public static Behavior&lt;Command&gt; create(CustomerDataAccess dataAccess) {
    return Behaviors.setup(context -&gt; new CustomerRepository(context, dataAccess));
  }

  private final CustomerDataAccess dataAccess;
  private int operationsInProgress = 0;

  private CustomerRepository(ActorContext&lt;Command&gt; context, CustomerDataAccess dataAccess) {
    super(context);
    this.dataAccess = dataAccess;
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Update.class, this::onUpdate)
        .onMessage(WrappedUpdateResult.class, this::onUpdateResult)
        .build();
  }

  private Behavior&lt;Command&gt; onUpdate(Update command) {
    if (operationsInProgress == MAX_OPERATIONS_IN_PROGRESS) {
      command.replyTo.tell(
          new UpdateFailure(
              command.customer.id,
              &quot;Max &quot; + MAX_OPERATIONS_IN_PROGRESS + &quot; concurrent operations supported&quot;));
    } else {
      // increase operationsInProgress counter
      operationsInProgress++;
      CompletionStage&lt;Done&gt; futureResult = dataAccess.update(command.customer);
      getContext()
          .pipeToSelf(
              futureResult,
              (ok, exc) -&gt; {
                if (exc == null)
                  return new WrappedUpdateResult(
                      new UpdateSuccess(command.customer.id), command.replyTo);
                else
                  return new WrappedUpdateResult(
                      new UpdateFailure(command.customer.id, exc.getMessage()),
                      command.replyTo);
              });
    }
    return this;
  }

  private Behavior&lt;Command&gt; onUpdateResult(WrappedUpdateResult wrapped) {
    // decrease operationsInProgress counter
    operationsInProgress--;
    // send result to original requestor
    wrapped.replyTo.tell(wrapped.result);
    return this;
  }
}</code></pre></dd>
</dl>
<p>It could be tempting to just use <span class="group-scala"><code>onComplete on the Future</code></span><span class="group-java"><code>a callback on the CompletionStage</code></span>, but that introduces the risk of accessing internal state of the actor that is not thread-safe from an external thread. For example, the <code>numberOfPendingOperations</code> counter in above example can&rsquo;t be accessed from such callback. Therefore it is better to map the result to a message and perform further processing when receiving that message.</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Accessing APIs that are returning <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> from an actor, such as a database or  an external service</li>
  <li>The actor needs to continue processing when the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> has completed</li>
  <li>Keep context from the original request and use that when the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> has completed,  for example an <code>replyTo</code> actor reference</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Boilerplate of adding wrapper messages for the results</li>
</ul>
<h2><a href="#per-session-child-actor" name="per-session-child-actor" class="anchor"><span class="anchor-link"></span></a>Per session child Actor</h2>
<p>In some cases a complete response to a request can only be created and sent back after collecting multiple answers from other actors. For these kinds of interaction it can be good to delegate the work to a per &ldquo;session&rdquo; child actor. The child could also contain arbitrary logic to implement retrying, failing on timeout, tail chopping, progress inspection etc.</p>
<p>Note that this is essentially how <code>ask</code> is implemented, if all you need is a single response with a timeout it is better to use <code>ask</code>.</p>
<p>The child is created with the context it needs to do the work, including an <code>ActorRef</code> that it can respond to. When the complete result is there the child responds with the result and stops itself.</p>
<p>As the protocol of the session actor is not a public API but rather an implementation detail of the parent actor, it may not always make sense to have an explicit protocol and adapt the messages of the actors that the session actor interacts with. For this use case it is possible to express that the actor can receive any message (<span class="group-scala"><code>Any</code></span><span class="group-java"><code>Object</code></span>).</p>
<p><strong>Example:</strong></p>
<p><img src="./images/per-session-child.png" alt="per-session-child.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L297-L387" target="_blank" title="Go to snippet source"></a><code class="language-scala">// dummy data types just for this sample
case class Keys()
case class Wallet()


object Home {
  sealed trait Command
  case class LeaveHome(who: String, replyTo: ActorRef[ReadyToLeaveHome]) extends Command
  case class ReadyToLeaveHome(who: String, keys: Keys, wallet: Wallet)

  def apply(): Behavior[Command] = {
    Behaviors.setup[Command] { context =&gt;
      val keyCabinet: ActorRef[KeyCabinet.GetKeys] = context.spawn(KeyCabinet(), &quot;key-cabinet&quot;)
      val drawer: ActorRef[Drawer.GetWallet] = context.spawn(Drawer(), &quot;drawer&quot;)

      Behaviors.receiveMessage[Command] {
        case LeaveHome(who, replyTo) =&gt;
          context.spawn(prepareToLeaveHome(who, replyTo, keyCabinet, drawer), s&quot;leaving-$who&quot;)
          Behaviors.same
      }
    }
  }

  // per session actor behavior
  def prepareToLeaveHome(
      whoIsLeaving: String,
      replyTo: ActorRef[ReadyToLeaveHome],
      keyCabinet: ActorRef[KeyCabinet.GetKeys],
      drawer: ActorRef[Drawer.GetWallet]): Behavior[NotUsed] = {
    // we don&#39;t _really_ care about the actor protocol here as nobody will send us
    // messages except for responses to our queries, so we just accept any kind of message
    // but narrow that to more limited types when we interact
    Behaviors
      .setup[AnyRef] { context =&gt;
        var wallet: Option[Wallet] = None
        var keys: Option[Keys] = None

        // we narrow the ActorRef type to any subtype of the actual type we accept
        keyCabinet ! KeyCabinet.GetKeys(whoIsLeaving, context.self.narrow[Keys])
        drawer ! Drawer.GetWallet(whoIsLeaving, context.self.narrow[Wallet])

        def nextBehavior(): Behavior[AnyRef] =
          (keys, wallet) match {
            case (Some(w), Some(k)) =&gt;
              // we got both, &quot;session&quot; is completed!
              replyTo ! ReadyToLeaveHome(whoIsLeaving, w, k)
              Behaviors.stopped

            case _ =&gt;
              Behaviors.same
          }

        Behaviors.receiveMessage {
          case w: Wallet =&gt;
            wallet = Some(w)
            nextBehavior()
          case k: Keys =&gt;
            keys = Some(k)
            nextBehavior()
          case _ =&gt;
            Behaviors.unhandled
        }
      }
      .narrow[NotUsed] // we don&#39;t let anyone else know we accept anything
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L460-L621" target="_blank" title="Go to snippet source"></a><code class="language-java">// dummy data types just for this sample
public class Keys {}

public class Wallet {}

public class KeyCabinet {
  public static class GetKeys {
    public final String whoseKeys;
    public final ActorRef&lt;Keys&gt; replyTo;

    public GetKeys(String whoseKeys, ActorRef&lt;Keys&gt; respondTo) {
      this.whoseKeys = whoseKeys;
      this.replyTo = respondTo;
    }
  }

  public static Behavior&lt;GetKeys&gt; create() {
    return Behaviors.receiveMessage(KeyCabinet::onGetKeys);
  }

  private static Behavior&lt;GetKeys&gt; onGetKeys(GetKeys message) {
    message.replyTo.tell(new Keys());
    return Behaviors.same();
  }
}

public class Drawer {

  public static class GetWallet {
    public final String whoseWallet;
    public final ActorRef&lt;Wallet&gt; replyTo;

    public GetWallet(String whoseWallet, ActorRef&lt;Wallet&gt; replyTo) {
      this.whoseWallet = whoseWallet;
      this.replyTo = replyTo;
    }
  }

  public static Behavior&lt;GetWallet&gt; create() {
    return Behaviors.receiveMessage(Drawer::onGetWallet);
  }

  private static Behavior&lt;GetWallet&gt; onGetWallet(GetWallet message) {
    message.replyTo.tell(new Wallet());
    return Behaviors.same();
  }
}

public class Home {

  public interface Command {}

  public static class LeaveHome implements Command {
    public final String who;
    public final ActorRef&lt;ReadyToLeaveHome&gt; respondTo;

    public LeaveHome(String who, ActorRef&lt;ReadyToLeaveHome&gt; respondTo) {
      this.who = who;
      this.respondTo = respondTo;
    }
  }

  public static class ReadyToLeaveHome {
    public final String who;
    public final Keys keys;
    public final Wallet wallet;

    public ReadyToLeaveHome(String who, Keys keys, Wallet wallet) {
      this.who = who;
      this.keys = keys;
      this.wallet = wallet;
    }
  }

  private final ActorContext&lt;Command&gt; context;

  private final ActorRef&lt;KeyCabinet.GetKeys&gt; keyCabinet;
  private final ActorRef&lt;Drawer.GetWallet&gt; drawer;

  private Home(ActorContext&lt;Command&gt; context) {
    this.context = context;
    this.keyCabinet = context.spawn(KeyCabinet.create(), &quot;key-cabinet&quot;);
    this.drawer = context.spawn(Drawer.create(), &quot;drawer&quot;);
  }

  private Behavior&lt;Command&gt; behavior() {
    return Behaviors.receive(Command.class)
        .onMessage(LeaveHome.class, this::onLeaveHome)
        .build();
  }

  private Behavior&lt;Command&gt; onLeaveHome(LeaveHome message) {
    context.spawn(
        PrepareToLeaveHome.create(message.who, message.respondTo, keyCabinet, drawer),
        &quot;leaving&quot; + message.who);
    return Behaviors.same();
  }

  // actor behavior
  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(context -&gt; new Home(context).behavior());
  }
}

// per session actor behavior
class PrepareToLeaveHome extends AbstractBehavior&lt;Object&gt; {
  static Behavior&lt;Object&gt; create(
      String whoIsLeaving,
      ActorRef&lt;Home.ReadyToLeaveHome&gt; replyTo,
      ActorRef&lt;KeyCabinet.GetKeys&gt; keyCabinet,
      ActorRef&lt;Drawer.GetWallet&gt; drawer) {
    return Behaviors.setup(
        context -&gt; new PrepareToLeaveHome(context, whoIsLeaving, replyTo, keyCabinet, drawer));
  }

  private final String whoIsLeaving;
  private final ActorRef&lt;Home.ReadyToLeaveHome&gt; replyTo;
  private final ActorRef&lt;KeyCabinet.GetKeys&gt; keyCabinet;
  private final ActorRef&lt;Drawer.GetWallet&gt; drawer;
  private Optional&lt;Wallet&gt; wallet = Optional.empty();
  private Optional&lt;Keys&gt; keys = Optional.empty();

  private PrepareToLeaveHome(
      ActorContext&lt;Object&gt; context,
      String whoIsLeaving,
      ActorRef&lt;Home.ReadyToLeaveHome&gt; replyTo,
      ActorRef&lt;KeyCabinet.GetKeys&gt; keyCabinet,
      ActorRef&lt;Drawer.GetWallet&gt; drawer) {
    super(context);
    this.whoIsLeaving = whoIsLeaving;
    this.replyTo = replyTo;
    this.keyCabinet = keyCabinet;
    this.drawer = drawer;
  }

  @Override
  public Receive&lt;Object&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Wallet.class, this::onWallet)
        .onMessage(Keys.class, this::onKeys)
        .build();
  }

  private Behavior&lt;Object&gt; onWallet(Wallet wallet) {
    this.wallet = Optional.of(wallet);
    return completeOrContinue();
  }

  private Behavior&lt;Object&gt; onKeys(Keys keys) {
    this.keys = Optional.of(keys);
    return completeOrContinue();
  }

  private Behavior&lt;Object&gt; completeOrContinue() {
    if (wallet.isPresent() &amp;&amp; keys.isPresent()) {
      replyTo.tell(new Home.ReadyToLeaveHome(whoIsLeaving, keys.get(), wallet.get()));
      return Behaviors.stopped();
    } else {
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>In an actual session child you would likely want to include some form of timeout as well (see <a href="interaction-patterns.html#scheduling-messages-to-self">scheduling messages to self</a>).</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>A single incoming request should result in multiple interactions with other actors before a result can be built,  for example aggregation of several results</li>
  <li>You need to handle acknowledgement and retry messages for at-least-once delivery</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped</li>
  <li>It increases complexity, since each such child can execute concurrently with other children and the parent</li>
</ul>
<h2><a href="#general-purpose-response-aggregator" name="general-purpose-response-aggregator" class="anchor"><span class="anchor-link"></span></a>General purpose response aggregator</h2>
<p>This is similar to above <a href="interaction-patterns.html#per-session-child-actor">Per session child Actor</a> pattern. Sometimes you might end up repeating the same way of aggregating replies and want to extract that to a reusable actor.</p>
<p>There are many variations of this pattern and that is the reason this is provided as a documentation example rather than a built in <code>Behavior</code> in Akka. It is intended to be adjusted to your specific needs.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/aggregator.png" alt="aggregator.png" /></p>
<p>This example is an aggregator of expected number of replies. Requests for quotes are sent with the given <code>sendRequests</code> function to the two hotel actors, which both speak different protocols. When both expected replies have been collected they are aggregated with the given <code>aggregateReplies</code> function and sent back to the <code>replyTo</code>. If replies don&rsquo;t arrive within the <code>timeout</code> the replies so far are aggregated and sent back to the <code>replyTo</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/AggregatorSpec.scala#L18-L66" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Hotel1 {
  final case class RequestQuote(replyTo: ActorRef[Quote])
  final case class Quote(hotel: String, price: BigDecimal)
}
object Hotel2 {
  final case class RequestPrice(replyTo: ActorRef[Price])
  final case class Price(hotel: String, price: BigDecimal)
}

// Any since no common type between Hotel1 and Hotel2
type Reply = Any

object HotelCustomer {
  sealed trait Command
  final case class Quote(hotel: String, price: BigDecimal)
  final case class AggregatedQuotes(quotes: List[Quote]) extends Command

  def apply(hotel1: ActorRef[Hotel1.RequestQuote], hotel2: ActorRef[Hotel2.RequestPrice]): Behavior[Command] = {

    Behaviors.setup[Command] { context =&gt;
      context.spawnAnonymous(
        Aggregator[Reply, AggregatedQuotes](
          sendRequests = { replyTo =&gt;
            hotel1 ! Hotel1.RequestQuote(replyTo)
            hotel2 ! Hotel2.RequestPrice(replyTo)
          },
          expectedReplies = 2,
          context.self,
          aggregateReplies = replies =&gt;
            // The hotels have different protocols with different replies,
            // convert them to `HotelCustomer.Quote` that this actor understands.
            AggregatedQuotes(
              replies
                .map {
                  case Hotel1.Quote(hotel, price) =&gt; Quote(hotel, price)
                  case Hotel2.Price(hotel, price) =&gt; Quote(hotel, price)
                }
                .sortBy(_.price)
                .toList),
          timeout = 5.seconds))

      Behaviors.receiveMessage {
        case AggregatedQuotes(quotes) =&gt;
          context.log.info(&quot;Best {}&quot;, quotes.headOption.getOrElse(&quot;Quote N/A&quot;))
          Behaviors.same
      }
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/AggregatorTest.java#L88-L214" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Hotel1 {
  public static class RequestQuote {
    public final ActorRef&lt;Quote&gt; replyTo;

    public RequestQuote(ActorRef&lt;Quote&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Quote {
    public final String hotel;
    public final BigDecimal price;

    public Quote(String hotel, BigDecimal price) {
      this.hotel = hotel;
      this.price = price;
    }
  }
}

public class Hotel2 {
  public static class RequestPrice {
    public final ActorRef&lt;Price&gt; replyTo;

    public RequestPrice(ActorRef&lt;Price&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class Price {
    public final String hotel;
    public final BigDecimal price;

    public Price(String hotel, BigDecimal price) {
      this.hotel = hotel;
      this.price = price;
    }
  }
}

public class HotelCustomer extends AbstractBehavior&lt;HotelCustomer.Command&gt; {

  interface Command {}

  public static class Quote {
    public final String hotel;
    public final BigDecimal price;

    public Quote(String hotel, BigDecimal price) {
      this.hotel = hotel;
      this.price = price;
    }
  }

  public static class AggregatedQuotes implements Command {
    public final List&lt;Quote&gt; quotes;

    public AggregatedQuotes(List&lt;Quote&gt; quotes) {
      this.quotes = quotes;
    }
  }

  public static Behavior&lt;Command&gt; create(
      ActorRef&lt;Hotel1.RequestQuote&gt; hotel1, ActorRef&lt;Hotel2.RequestPrice&gt; hotel2) {
    return Behaviors.setup(context -&gt; new HotelCustomer(context, hotel1, hotel2));
  }

  public HotelCustomer(
      ActorContext&lt;Command&gt; context,
      ActorRef&lt;Hotel1.RequestQuote&gt; hotel1,
      ActorRef&lt;Hotel2.RequestPrice&gt; hotel2) {
    super(context);

    Consumer&lt;ActorRef&lt;Object&gt;&gt; sendRequests =
        replyTo -&gt; {
          hotel1.tell(new Hotel1.RequestQuote(replyTo.narrow()));
          hotel2.tell(new Hotel2.RequestPrice(replyTo.narrow()));
        };

    int expectedReplies = 2;
    // Object since no common type between Hotel1 and Hotel2
    context.spawnAnonymous(
        Aggregator.create(
            Object.class,
            sendRequests,
            expectedReplies,
            context.getSelf(),
            this::aggregateReplies,
            Duration.ofSeconds(5)));
  }

  private AggregatedQuotes aggregateReplies(List&lt;Object&gt; replies) {
    List&lt;Quote&gt; quotes =
        replies.stream()
            .map(
                r -&gt; {
                  // The hotels have different protocols with different replies,
                  // convert them to `HotelCustomer.Quote` that this actor understands.
                  if (r instanceof Hotel1.Quote) {
                    Hotel1.Quote q = (Hotel1.Quote) r;
                    return new Quote(q.hotel, q.price);
                  } else if (r instanceof Hotel2.Price) {
                    Hotel2.Price p = (Hotel2.Price) r;
                    return new Quote(p.hotel, p.price);
                  } else {
                    throw new IllegalArgumentException(&quot;Unknown reply &quot; + r);
                  }
                })
            .sorted((a, b) -&gt; a.price.compareTo(b.price))
            .collect(Collectors.toList());

    return new AggregatedQuotes(quotes);
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(AggregatedQuotes.class, this::onAggregatedQuotes)
        .build();
  }

  private Behavior&lt;Command&gt; onAggregatedQuotes(AggregatedQuotes aggregated) {
    if (aggregated.quotes.isEmpty()) getContext().getLog().info(&quot;Best Quote N/A&quot;);
    else getContext().getLog().info(&quot;Best {}&quot;, aggregated.quotes.get(0));
    return this;
  }
}</code></pre></dd>
</dl>
<p>The implementation of the <code>Aggregator</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/Aggregator.scala#L8-L55" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.collection.immutable
import scala.concurrent.duration.FiniteDuration
import scala.reflect.ClassTag

import akka.actor.typed.ActorRef
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors

object Aggregator {

  sealed trait Command
  private case object ReceiveTimeout extends Command
  private case class WrappedReply[R](reply: R) extends Command

  def apply[Reply: ClassTag, Aggregate](
      sendRequests: ActorRef[Reply] =&gt; Unit,
      expectedReplies: Int,
      replyTo: ActorRef[Aggregate],
      aggregateReplies: immutable.IndexedSeq[Reply] =&gt; Aggregate,
      timeout: FiniteDuration): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      context.setReceiveTimeout(timeout, ReceiveTimeout)
      val replyAdapter = context.messageAdapter[Reply](WrappedReply(_))
      sendRequests(replyAdapter)

      def collecting(replies: immutable.IndexedSeq[Reply]): Behavior[Command] = {
        Behaviors.receiveMessage {
          case WrappedReply(reply: Reply) =&gt;
            val newReplies = replies :+ reply
            if (newReplies.size == expectedReplies) {
              val result = aggregateReplies(newReplies)
              replyTo ! result
              Behaviors.stopped
            } else
              collecting(newReplies)

          case ReceiveTimeout =&gt;
            val aggregate = aggregateReplies(replies)
            replyTo ! aggregate
            Behaviors.stopped
        }
      }

      collecting(Vector.empty)
    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/Aggregator.java#L8-L105" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;

public class Aggregator&lt;Reply, Aggregate&gt; extends AbstractBehavior&lt;Aggregator.Command&gt; {

  interface Command {}

  private enum ReceiveTimeout implements Command {
    INSTANCE
  }

  private class WrappedReply implements Command {
    final Reply reply;

    private WrappedReply(Reply reply) {
      this.reply = reply;
    }
  }

  public static &lt;R, A&gt; Behavior&lt;Command&gt; create(
      Class&lt;R&gt; replyClass,
      Consumer&lt;ActorRef&lt;R&gt;&gt; sendRequests,
      int expectedReplies,
      ActorRef&lt;A&gt; replyTo,
      Function&lt;List&lt;R&gt;, A&gt; aggregateReplies,
      Duration timeout) {
    return Behaviors.setup(
        context -&gt;
            new Aggregator&lt;R, A&gt;(
                replyClass,
                context,
                sendRequests,
                expectedReplies,
                replyTo,
                aggregateReplies,
                timeout));
  }

  private final int expectedReplies;
  private final ActorRef&lt;Aggregate&gt; replyTo;
  private final Function&lt;List&lt;Reply&gt;, Aggregate&gt; aggregateReplies;
  private final List&lt;Reply&gt; replies = new ArrayList&lt;&gt;();

  private Aggregator(
      Class&lt;Reply&gt; replyClass,
      ActorContext&lt;Command&gt; context,
      Consumer&lt;ActorRef&lt;Reply&gt;&gt; sendRequests,
      int expectedReplies,
      ActorRef&lt;Aggregate&gt; replyTo,
      Function&lt;List&lt;Reply&gt;, Aggregate&gt; aggregateReplies,
      Duration timeout) {
    super(context);
    this.expectedReplies = expectedReplies;
    this.replyTo = replyTo;
    this.aggregateReplies = aggregateReplies;

    context.setReceiveTimeout(timeout, ReceiveTimeout.INSTANCE);

    ActorRef&lt;Reply&gt; replyAdapter = context.messageAdapter(replyClass, WrappedReply::new);
    sendRequests.accept(replyAdapter);
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(WrappedReply.class, this::onReply)
        .onMessage(ReceiveTimeout.class, notUsed -&gt; onReceiveTimeout())
        .build();
  }

  private Behavior&lt;Command&gt; onReply(WrappedReply wrappedReply) {
    Reply reply = wrappedReply.reply;
    replies.add(reply);
    if (replies.size() == expectedReplies) {
      Aggregate result = aggregateReplies.apply(replies);
      replyTo.tell(result);
      return Behaviors.stopped();
    } else {
      return this;
    }
  }

  private Behavior&lt;Command&gt; onReceiveTimeout() {
    Aggregate result = aggregateReplies.apply(replies);
    replyTo.tell(result);
    return Behaviors.stopped();
  }
}</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Aggregating replies are performed in the same way at multiple places and should be extracted to a more general  purpose actor.</li>
  <li>A single incoming request should result in multiple interactions with other actors before a result can be built,  for example aggregation of several results</li>
  <li>You need to handle acknowledgement and retry messages for at-least-once delivery</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Message protocols with generic types are difficult since the generic types are erased in runtime</li>
  <li>Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped</li>
  <li>It increases complexity, since each such child can execute concurrently with other children and the parent</li>
</ul>
<h2><a href="#latency-tail-chopping" name="latency-tail-chopping" class="anchor"><span class="anchor-link"></span></a>Latency tail chopping</h2>
<p>This is a variation of above <a href="interaction-patterns.html#general-purpose-response-aggregator">General purpose response aggregator</a> pattern.</p>
<p>The goal of this algorithm is to decrease tail latencies (&ldquo;chop off the tail latency&rdquo;) in situations where multiple destination actors can perform the same piece of work, and where an actor may occasionally respond more slowly than expected. In this case, sending the same work request (also known as a &ldquo;backup request&rdquo;) to another actor results in decreased response time - because it&rsquo;s less probable that multiple actors are under heavy load simultaneously. This technique is explained in depth in Jeff Dean&rsquo;s presentation on <a href="http://static.googleusercontent.com/media/research.google.com/en//people/jeff/Berkeley-Latency-Mar2012.pdf">Achieving Rapid Response Times in Large Online Services</a>.</p>
<p>There are many variations of this pattern and that is the reason this is provided as a documentation example rather than a built in <code>Behavior</code> in Akka. It is intended to be adjusted to your specific needs.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/tail-chopping.png" alt="tail-chopping.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/TailChopping.scala#L8-L61" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration.FiniteDuration
import scala.reflect.ClassTag

import akka.actor.typed.ActorRef
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors

object TailChopping {

  sealed trait Command
  private case object RequestTimeout extends Command
  private case object FinalTimeout extends Command
  private case class WrappedReply[R](reply: R) extends Command

  def apply[Reply: ClassTag](
      sendRequest: (Int, ActorRef[Reply]) =&gt; Boolean,
      nextRequestAfter: FiniteDuration,
      replyTo: ActorRef[Reply],
      finalTimeout: FiniteDuration,
      timeoutReply: Reply): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      Behaviors.withTimers { timers =&gt;
        val replyAdapter = context.messageAdapter[Reply](WrappedReply(_))

        def waiting(requestCount: Int): Behavior[Command] = {
          Behaviors.receiveMessage {
            case WrappedReply(reply: Reply) =&gt;
              replyTo ! reply
              Behaviors.stopped

            case RequestTimeout =&gt;
              sendNextRequest(requestCount + 1)

            case FinalTimeout =&gt;
              replyTo ! timeoutReply
              Behaviors.stopped
          }
        }

        def sendNextRequest(requestCount: Int): Behavior[Command] = {
          if (sendRequest(requestCount, replyAdapter)) {
            timers.startSingleTimer(RequestTimeout, nextRequestAfter)
          } else {
            timers.startSingleTimer(FinalTimeout, finalTimeout)
          }
          waiting(requestCount)
        }

        sendNextRequest(1)
      }
    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/TailChopping.java#L8-L126" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;
import akka.actor.typed.javadsl.TimerScheduler;

import java.time.Duration;
import java.util.function.BiFunction;

public class TailChopping&lt;Reply&gt; extends AbstractBehavior&lt;TailChopping.Command&gt; {

  interface Command {}

  private enum RequestTimeout implements Command {
    INSTANCE
  }

  private enum FinalTimeout implements Command {
    INSTANCE
  }

  private class WrappedReply implements Command {
    final Reply reply;

    private WrappedReply(Reply reply) {
      this.reply = reply;
    }
  }

  public static &lt;R&gt; Behavior&lt;Command&gt; create(
      Class&lt;R&gt; replyClass,
      BiFunction&lt;Integer, ActorRef&lt;R&gt;, Boolean&gt; sendRequest,
      Duration nextRequestAfter,
      ActorRef&lt;R&gt; replyTo,
      Duration finalTimeout,
      R timeoutReply) {
    return Behaviors.setup(
        context -&gt;
            Behaviors.withTimers(
                timers -&gt;
                    new TailChopping&lt;R&gt;(
                        replyClass,
                        context,
                        timers,
                        sendRequest,
                        nextRequestAfter,
                        replyTo,
                        finalTimeout,
                        timeoutReply)));
  }

  private final TimerScheduler&lt;Command&gt; timers;
  private final BiFunction&lt;Integer, ActorRef&lt;Reply&gt;, Boolean&gt; sendRequest;
  private final Duration nextRequestAfter;
  private final ActorRef&lt;Reply&gt; replyTo;
  private final Duration finalTimeout;
  private final Reply timeoutReply;
  private final ActorRef&lt;Reply&gt; replyAdapter;

  private int requestCount = 0;

  private TailChopping(
      Class&lt;Reply&gt; replyClass,
      ActorContext&lt;Command&gt; context,
      TimerScheduler&lt;Command&gt; timers,
      BiFunction&lt;Integer, ActorRef&lt;Reply&gt;, Boolean&gt; sendRequest,
      Duration nextRequestAfter,
      ActorRef&lt;Reply&gt; replyTo,
      Duration finalTimeout,
      Reply timeoutReply) {
    super(context);
    this.timers = timers;
    this.sendRequest = sendRequest;
    this.nextRequestAfter = nextRequestAfter;
    this.replyTo = replyTo;
    this.finalTimeout = finalTimeout;
    this.timeoutReply = timeoutReply;

    replyAdapter = context.messageAdapter(replyClass, WrappedReply::new);

    sendNextRequest();
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(WrappedReply.class, this::onReply)
        .onMessage(RequestTimeout.class, notUsed -&gt; onRequestTimeout())
        .onMessage(FinalTimeout.class, notUsed -&gt; onFinalTimeout())
        .build();
  }

  private Behavior&lt;Command&gt; onReply(WrappedReply wrappedReply) {
    Reply reply = wrappedReply.reply;
    replyTo.tell(reply);
    return Behaviors.stopped();
  }

  private Behavior&lt;Command&gt; onRequestTimeout() {
    sendNextRequest();
    return this;
  }

  private Behavior&lt;Command&gt; onFinalTimeout() {
    replyTo.tell(timeoutReply);
    return Behaviors.stopped();
  }

  private void sendNextRequest() {
    requestCount++;
    if (sendRequest.apply(requestCount, replyAdapter)) {
      timers.startSingleTimer(RequestTimeout.INSTANCE, RequestTimeout.INSTANCE, nextRequestAfter);
    } else {
      timers.startSingleTimer(FinalTimeout.INSTANCE, FinalTimeout.INSTANCE, finalTimeout);
    }
  }
}</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Reducing higher latency percentiles and variations of latency are important</li>
  <li>The &ldquo;work&rdquo; can be done more than once with the same result, e.g. a request to retrieve information</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Increased load since more messages are sent and &ldquo;work&rdquo; is performed more than once</li>
  <li>Can&rsquo;t be used when the &ldquo;work&rdquo; is not idempotent and must only be performed once</li>
  <li>Message protocols with generic types are difficult since the generic types are erased in runtime</li>
  <li>Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped</li>
</ul>
<a id="typed-scheduling"></a>
<h2><a href="#scheduling-messages-to-self" name="scheduling-messages-to-self" class="anchor"><span class="anchor-link"></span></a>Scheduling messages to self</h2>
<p>The following example demonstrates how to use timers to schedule messages to an actor. </p>
<p><strong>Example:</strong></p>
<p><img src="./images/timer.png" alt="timer.png" /></p>
<p>The <code>Buncher</code> actor buffers a burst of incoming messages and delivers them as a batch after a timeout or when the number of batched messages exceeds a maximum size.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L173-L215" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Buncher {

  sealed trait Command
  final case class ExcitingMessage(message: String) extends Command
  final case class Batch(messages: Vector[Command])
  private case object Timeout extends Command
  private case object TimerKey

  def apply(target: ActorRef[Batch], after: FiniteDuration, maxSize: Int): Behavior[Command] = {
    Behaviors.withTimers(timers =&gt; new Buncher(timers, target, after, maxSize).idle())
  }
}

class Buncher(
    timers: TimerScheduler[Buncher.Command],
    target: ActorRef[Buncher.Batch],
    after: FiniteDuration,
    maxSize: Int) {
  import Buncher._

  private def idle(): Behavior[Command] = {
    Behaviors.receiveMessage[Command] { message =&gt;
      timers.startSingleTimer(TimerKey, Timeout, after)
      active(Vector(message))
    }
  }

  def active(buffer: Vector[Command]): Behavior[Command] = {
    Behaviors.receiveMessage[Command] {
      case Timeout =&gt;
        target ! Batch(buffer)
        idle()
      case m =&gt;
        val newBuffer = buffer :+ m
        if (newBuffer.size == maxSize) {
          timers.cancel(TimerKey)
          target ! Batch(newBuffer)
          idle()
        } else
          active(newBuffer)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L234-L338" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Buncher {

  public interface Command {}

  public static final class Batch {
    private final List&lt;Command&gt; messages;

    public Batch(List&lt;Command&gt; messages) {
      this.messages = Collections.unmodifiableList(messages);
    }

    public List&lt;Command&gt; getMessages() {
      return messages;
    }
  }

  public static final class ExcitingMessage implements Command {
    public final String message;

    public ExcitingMessage(String message) {
      this.message = message;
    }
  }

  private static final Object TIMER_KEY = new Object();

  private enum Timeout implements Command {
    INSTANCE
  }

  public static Behavior&lt;Command&gt; create(ActorRef&lt;Batch&gt; target, Duration after, int maxSize) {
    return Behaviors.withTimers(timers -&gt; new Buncher(timers, target, after, maxSize).idle());
  }

  private final TimerScheduler&lt;Command&gt; timers;
  private final ActorRef&lt;Batch&gt; target;
  private final Duration after;
  private final int maxSize;

  private Buncher(
      TimerScheduler&lt;Command&gt; timers, ActorRef&lt;Batch&gt; target, Duration after, int maxSize) {
    this.timers = timers;
    this.target = target;
    this.after = after;
    this.maxSize = maxSize;
  }

  private Behavior&lt;Command&gt; idle() {
    return Behaviors.receive(Command.class)
        .onMessage(Command.class, this::onIdleCommand)
        .build();
  }

  private Behavior&lt;Command&gt; onIdleCommand(Command message) {
    timers.startSingleTimer(TIMER_KEY, Timeout.INSTANCE, after);
    return Behaviors.setup(context -&gt; new Active(context, message));
  }

  private class Active extends AbstractBehavior&lt;Command&gt; {

    private final List&lt;Command&gt; buffer = new ArrayList&lt;&gt;();

    Active(ActorContext&lt;Command&gt; context, Command firstCommand) {
      super(context);
      buffer.add(firstCommand);
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(Timeout.class, message -&gt; onTimeout())
          .onMessage(Command.class, this::onCommand)
          .build();
    }

    private Behavior&lt;Command&gt; onTimeout() {
      target.tell(new Batch(buffer));
      return idle(); // switch to idle
    }

    private Behavior&lt;Command&gt; onCommand(Command message) {
      buffer.add(message);
      if (buffer.size() == maxSize) {
        timers.cancel(TIMER_KEY);
        target.tell(new Batch(buffer));
        return idle(); // switch to idle
      } else {
        return this; // stay Active
      }
    }
  }
}</code></pre></dd>
</dl>
<p>There are a few things worth noting here:</p>
<ul>
  <li>To get access to the timers you start with <code>Behaviors.withTimers</code> that will pass a <code>TimerScheduler</code> instance to the function. This can be used with any type of <code>Behavior</code>, including <code>receive</code>, <code>receiveMessage</code>, but also <code>setup</code> or any other behavior.</li>
  <li>Each timer has a key and if a new timer with the same key is started, the previous is cancelled. It is guaranteed that a message from the previous timer is not received, even if it was already enqueued in the mailbox when the new timer was started.</li>
  <li>Both periodic and single message timers are supported.</li>
  <li>The <code>TimerScheduler</code> is mutable in itself, because it performs and manages the side effects of registering the scheduled tasks.</li>
  <li>The <code>TimerScheduler</code> is bound to the lifecycle of the actor that owns it and is cancelled automatically when the actor is stopped.</li>
  <li><code>Behaviors.withTimers</code> can also be used inside <code>Behaviors.supervise</code> and it will automatically cancel the started timers correctly when the actor is restarted, so that the new incarnation will not receive scheduled messages from a previous incarnation.</li>
</ul>
<h3><a href="#schedule-periodically" name="schedule-periodically" class="anchor"><span class="anchor-link"></span></a>Schedule periodically</h3>
<p>Scheduling of recurring messages can have two different characteristics:</p>
<ul>
  <li>fixed-delay - The delay between sending subsequent messages will always be (at least) the given <code>delay</code>.  Use <code>startTimerWithFixedDelay</code>.</li>
  <li>fixed-rate - The frequency of execution over time will meet the given <code>interval</code>. Use <code>startTimerAtFixedRate</code>.</li>
</ul>
<p>If you are uncertain of which one to use you should pick <code>startTimerWithFixedDelay</code>.</p>
<p>When using <strong>fixed-delay</strong> it will not compensate the delay between messages if the scheduling is delayed longer than specified for some reason. The delay between sending subsequent messages will always be (at least) the given <code>delay</code>. In the long run, the frequency of messages will generally be slightly lower than the reciprocal of the specified <code>delay</code>.</p>
<p>Fixed-delay execution is appropriate for recurring activities that require &ldquo;smoothness.&rdquo; In other words, it is appropriate for activities where it is more important to keep the frequency accurate in the short run than in the long run.</p>
<p>When using <strong>fixed-rate</strong> it will compensate the delay for a subsequent task if the previous messages were delayed too long. In such cases, the actual sending interval will differ from the interval passed to the <code>scheduleAtFixedRate</code> method.</p>
<p>If the tasks are delayed longer than the <code>interval</code>, the subsequent message will be sent immediately after the prior one. This also has the consequence that after long garbage collection pauses or other reasons when the JVM was suspended all &ldquo;missed&rdquo; tasks will execute when the process wakes up again. For example, <code>scheduleAtFixedRate</code> with an interval of 1 second and the process is suspended for 30 seconds will result in 30 messages being sent in rapid succession to catch up. In the long run, the frequency of execution will be exactly the reciprocal of the specified <code>interval</code>.</p>
<p>Fixed-rate execution is appropriate for recurring activities that are sensitive to absolute time or where the total time to perform a fixed number of executions is important, such as a countdown timer that ticks once every second for ten seconds.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p><code>scheduleAtFixedRate</code> can result in bursts of scheduled messages after long garbage collection pauses, which may in worst case cause undesired load on the system. <code>scheduleWithFixedDelay</code> is often preferred.</p></div>
<h2><a href="#responding-to-a-sharded-actor" name="responding-to-a-sharded-actor" class="anchor"><span class="anchor-link"></span></a>Responding to a sharded actor</h2>
<p>When <a href="cluster.html">Akka Cluster</a> is used to <a href="cluster-sharding.html">shard actors</a> you need to take into account that an actor may move or get passivated.</p>
<p>The normal pattern for expecting a reply is to include an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/actor/typed/ActorRef.html" title="akka.actor.typed.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/actor/typed/ActorRef.html" title="akka.actor.typed.ActorRef"><code>ActorRef</code></a></span> in the message, typically a message adapter. This can be used for a sharded actor but if <span class="group-scala"><code>ctx.self</code></span><span class="group-java"><code>ctx.getSelf()</code></span> is sent and the sharded actor is moved or passivated then the reply will sent to dead letters.</p>
<p>An alternative is to send the <code>entityId</code> in the message and have the reply sent via sharding.</p>
<p><strong>Example:</strong></p>
<p><img src="./images/sharded-response.png" alt="sharded-response.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L139-L168" target="_blank" title="Go to snippet source"></a><code class="language-scala">// a sharded actor that needs counter updates
object CounterConsumer {
  sealed trait Command
  final case class NewCount(count: Long) extends Command
  val TypeKey: EntityTypeKey[Command] = EntityTypeKey[Command](&quot;example-sharded-response&quot;)
}

// a sharded counter that sends responses to another sharded actor
object Counter {
  trait Command
  case object Increment extends Command
  final case class GetValue(replyToEntityId: String) extends Command
  val TypeKey: EntityTypeKey[Command] = EntityTypeKey[Command](&quot;example-sharded-counter&quot;)

  private def apply(): Behavior[Command] =
    Behaviors.setup { context =&gt;
      counter(ClusterSharding(context.system), 0)
    }

  private def counter(sharding: ClusterSharding, value: Long): Behavior[Command] =
    Behaviors.receiveMessage {
      case Increment =&gt;
        counter(sharding, value + 1)
      case GetValue(replyToEntityId) =&gt;
        val replyToEntityRef = sharding.entityRefFor(CounterConsumer.TypeKey, replyToEntityId)
        replyToEntityRef ! CounterConsumer.NewCount(value)
        Behaviors.same
    }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.4/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingReplyCompileOnlyTest.java#L19-L85" target="_blank" title="Go to snippet source"></a><code class="language-java">// a sharded actor that needs counter updates
public class CounterConsumer {
  public static EntityTypeKey&lt;Command&gt; typeKey =
      EntityTypeKey.create(Command.class, &quot;example-sharded-response&quot;);

  public interface Command {}

  public static class NewCount implements Command {
    public final long value;

    public NewCount(long value) {
      this.value = value;
    }
  }
}

// a sharded counter that sends responses to another sharded actor
public class Counter extends AbstractBehavior&lt;Counter.Command&gt; {
  public static EntityTypeKey&lt;Command&gt; typeKey =
      EntityTypeKey.create(Command.class, &quot;example-sharded-counter&quot;);

  public interface Command {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    public final String replyToEntityId;

    public GetValue(String replyToEntityId) {
      this.replyToEntityId = replyToEntityId;
    }
  }

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(Counter::new);
  }

  private final ClusterSharding sharding;
  private int value = 0;

  private Counter(ActorContext&lt;Command&gt; context) {
    super(context);
    this.sharding = ClusterSharding.get(context.getSystem());
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Increment.class, msg -&gt; onIncrement())
        .onMessage(GetValue.class, this::onGetValue)
        .build();
  }

  private Behavior&lt;Command&gt; onIncrement() {
    value++;
    return this;
  }

  private Behavior&lt;Command&gt; onGetValue(GetValue msg) {
    EntityRef&lt;CounterConsumer.Command&gt; entityRef =
        sharding.entityRefFor(CounterConsumer.typeKey, msg.replyToEntityId);
    entityRef.tell(new CounterConsumer.NewCount(value));
    return this;
  }
}</code></pre></dd>
</dl>
<p>A disadvantage is that a message adapter can&rsquo;t be used so the response has to be in the protocol of the actor being responded to. Additionally the <code>EntityTypeKey</code> could be included in the message if it is not known statically.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/actor-lifecycle.html"><i class="icon-prev"></i> <span class="link-prev">Actor lifecycle</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/fault-tolerance.html">Fault Tolerance <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.6.4/akka-docs-zh/src/main/paradox/typed/interaction-patterns.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
